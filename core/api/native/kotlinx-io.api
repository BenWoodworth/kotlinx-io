package <root>
{
}

package kotlinx
{
}

package kotlinx.io
{
}

package kotlinx.io.streams
{
   public fun Input(fileDescriptor: kotlin.Int): kotlinx.io.core.Input

   public fun Input(file: kotlinx.cinterop.CPointer<platform.posix.FILE /* = platform.posix.__sFILE */>): kotlinx.io.core.Input

   public fun Output(fileDescriptor: kotlin.Int): kotlinx.io.core.Output

   public fun Output(file: kotlinx.cinterop.CPointer<platform.posix.FILE /* = platform.posix.__sFILE */>): kotlinx.io.core.Output

   public fun fread(destination: kotlinx.io.bits.Memory, offset: kotlin.Int, length: kotlin.Int, stream: kotlinx.cinterop.CPointer<platform.posix.FILE /* = platform.posix.__sFILE */>): kotlin.Int

   public fun fread(destination: kotlinx.io.bits.Memory, offset: kotlin.Long, length: kotlin.Long, stream: kotlinx.cinterop.CPointer<platform.posix.FILE /* = platform.posix.__sFILE */>): kotlin.Long

   public fun fread(buffer: kotlinx.io.core.Buffer, stream: kotlinx.cinterop.CPointer<platform.posix.FILE /* = platform.posix.__sFILE */>): platform.posix.size_t /* = kotlin.ULong */

   public fun fwrite(source: kotlinx.io.bits.Memory, offset: kotlin.Int, length: kotlin.Int, stream: kotlinx.cinterop.CPointer<platform.posix.FILE /* = platform.posix.__sFILE */>): kotlin.Int

   public fun fwrite(source: kotlinx.io.bits.Memory, offset: kotlin.Long, length: kotlin.Long, stream: kotlinx.cinterop.CPointer<platform.posix.FILE /* = platform.posix.__sFILE */>): kotlin.Long

   public fun fwrite(buffer: kotlinx.io.core.Buffer, stream: kotlinx.cinterop.CPointer<platform.posix.FILE /* = platform.posix.__sFILE */>): platform.posix.size_t /* = kotlin.ULong */

   public fun read(fildes: kotlin.Int, destination: kotlinx.io.bits.Memory, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

   public fun read(fildes: kotlin.Int, destination: kotlinx.io.bits.Memory, offset: kotlin.Long, length: kotlin.Long): kotlin.Long

   public fun read(fildes: kotlin.Int, buffer: kotlinx.io.core.Buffer): platform.posix.ssize_t /* = kotlin.Long */

   public fun recv(socket: kotlinx.io.internal.utils.KX_SOCKET /* = kotlin.Int */, buffer: kotlinx.io.core.Buffer, flags: kotlin.Int): platform.posix.ssize_t /* = kotlin.Long */

   public fun recvfrom(socket: kotlinx.io.internal.utils.KX_SOCKET /* = kotlin.Int */, buffer: kotlinx.io.core.Buffer, flags: kotlin.Int, addr: kotlinx.cinterop.CValuesRef<platform.posix.sockaddr>, addr_len: kotlinx.cinterop.CValuesRef<kotlinx.io.internal.utils.KX_SOCKADDR_LENVar /* = kotlinx.cinterop.UIntVarOf<kotlinx.io.internal.utils.KX_SOCKADDR_LEN /* = kotlin.UInt */> */>): platform.posix.ssize_t /* = kotlin.Long */

   public fun send(socket: kotlinx.io.internal.utils.KX_SOCKET /* = kotlin.Int */, source: kotlinx.io.bits.Memory, sourceOffset: kotlin.Int, maxLength: kotlin.Int, flags: kotlin.Int): kotlin.Int

   public fun send(socket: kotlinx.io.internal.utils.KX_SOCKET /* = kotlin.Int */, source: kotlinx.io.bits.Memory, sourceOffset: kotlin.Long, maxLength: kotlin.Long, flags: kotlin.Int): kotlin.Long

   public fun send(socket: kotlinx.io.internal.utils.KX_SOCKET /* = kotlin.Int */, buffer: kotlinx.io.core.Buffer, flags: kotlin.Int): platform.posix.ssize_t /* = kotlin.Long */

   public fun sendto(socket: kotlinx.io.internal.utils.KX_SOCKET /* = kotlin.Int */, buffer: kotlinx.io.core.Buffer, flags: kotlin.Int, addr: kotlinx.cinterop.CValuesRef<platform.posix.sockaddr>, addr_len: kotlinx.io.internal.utils.KX_SOCKADDR_LEN /* = kotlin.UInt */): platform.posix.ssize_t /* = kotlin.Long */

   public fun write(fildes: kotlin.Int, source: kotlinx.io.bits.Memory, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

   public fun write(fildes: kotlin.Int, source: kotlinx.io.bits.Memory, offset: kotlin.Long, length: kotlin.Long): kotlin.Long

   public fun write(fildes: kotlin.Int, buffer: kotlinx.io.core.Buffer): platform.posix.ssize_t /* = kotlin.Long */

   public inline fun <R> kotlinx.cinterop.CPointer<platform.posix.FILE /* = platform.posix.__sFILE */>.use(block: (kotlinx.cinterop.CPointer<platform.posix.FILE /* = platform.posix.__sFILE */>) -> R): R

}

package kotlinx.io.errors
{
   public open class EOFException : kotlinx.io.errors.IOException
   {
       public open override val cause: kotlin.Throwable? { get; }
       public open override val message: kotlin.String? { get; }
       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public final override fun getStackTrace(): kotlin.Array<kotlin.String>

       public open override fun hashCode(): kotlin.Int

       public final override fun printStackTrace(): kotlin.Unit

       public open override fun toString(): kotlin.String

       public constructor EOFException(message: kotlin.String)

   }

   public open class IOException : kotlin.Exception
   {
       public open override val cause: kotlin.Throwable? { get; }
       public open override val message: kotlin.String? { get; }
       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public final override fun getStackTrace(): kotlin.Array<kotlin.String>

       public open override fun hashCode(): kotlin.Int

       public final override fun printStackTrace(): kotlin.Unit

       public open override fun toString(): kotlin.String

       public constructor IOException(message: kotlin.String)

       public constructor IOException(message: kotlin.String, cause: kotlin.Throwable?)

   }

   public sealed class PosixException : kotlin.Exception
   {
       public open override val cause: kotlin.Throwable? { get; }
       public final val errno: kotlin.Int { get; }
       public open override val message: kotlin.String? { get; }
       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public final override fun getStackTrace(): kotlin.Array<kotlin.String>

       public open override fun hashCode(): kotlin.Int

       public final override fun printStackTrace(): kotlin.Unit

       public open override fun toString(): kotlin.String

       public final class AddressAlreadyInUseException : kotlinx.io.errors.PosixException
       {
           public open override val cause: kotlin.Throwable? { get; }
           public final override val errno: kotlin.Int { get; }
           public open override val message: kotlin.String? { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public final override fun getStackTrace(): kotlin.Array<kotlin.String>

           public open override fun hashCode(): kotlin.Int

           public final override fun printStackTrace(): kotlin.Unit

           public open override fun toString(): kotlin.String

           public constructor AddressAlreadyInUseException(message: kotlin.String)

       }

       public final class BadFileDescriptorException : kotlinx.io.errors.PosixException
       {
           public open override val cause: kotlin.Throwable? { get; }
           public final override val errno: kotlin.Int { get; }
           public open override val message: kotlin.String? { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public final override fun getStackTrace(): kotlin.Array<kotlin.String>

           public open override fun hashCode(): kotlin.Int

           public final override fun printStackTrace(): kotlin.Unit

           public open override fun toString(): kotlin.String

           public constructor BadFileDescriptorException(message: kotlin.String)

       }

       public final class BadMessageException : kotlinx.io.errors.PosixException
       {
           public open override val cause: kotlin.Throwable? { get; }
           public final override val errno: kotlin.Int { get; }
           public open override val message: kotlin.String? { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public final override fun getStackTrace(): kotlin.Array<kotlin.String>

           public open override fun hashCode(): kotlin.Int

           public final override fun printStackTrace(): kotlin.Unit

           public open override fun toString(): kotlin.String

           public constructor BadMessageException(message: kotlin.String)

       }

       public companion object of PosixException
       {
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public final fun forErrno(errno: kotlin.Int = ..., posixFunctionName: kotlin.String? = ...): kotlinx.io.errors.PosixException

           public open override fun hashCode(): kotlin.Int

           public open override fun toString(): kotlin.String

       }

       public final class ConnectionAbortedException : kotlinx.io.errors.PosixException
       {
           public open override val cause: kotlin.Throwable? { get; }
           public final override val errno: kotlin.Int { get; }
           public open override val message: kotlin.String? { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public final override fun getStackTrace(): kotlin.Array<kotlin.String>

           public open override fun hashCode(): kotlin.Int

           public final override fun printStackTrace(): kotlin.Unit

           public open override fun toString(): kotlin.String

           public constructor ConnectionAbortedException(message: kotlin.String)

       }

       public final class ConnectionRefusedException : kotlinx.io.errors.PosixException
       {
           public open override val cause: kotlin.Throwable? { get; }
           public final override val errno: kotlin.Int { get; }
           public open override val message: kotlin.String? { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public final override fun getStackTrace(): kotlin.Array<kotlin.String>

           public open override fun hashCode(): kotlin.Int

           public final override fun printStackTrace(): kotlin.Unit

           public open override fun toString(): kotlin.String

           public constructor ConnectionRefusedException(message: kotlin.String)

       }

       public final class ConnectionResetException : kotlinx.io.errors.PosixException
       {
           public open override val cause: kotlin.Throwable? { get; }
           public final override val errno: kotlin.Int { get; }
           public open override val message: kotlin.String? { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public final override fun getStackTrace(): kotlin.Array<kotlin.String>

           public open override fun hashCode(): kotlin.Int

           public final override fun printStackTrace(): kotlin.Unit

           public open override fun toString(): kotlin.String

           public constructor ConnectionResetException(message: kotlin.String)

       }

       public final class InterruptedException : kotlinx.io.errors.PosixException
       {
           public open override val cause: kotlin.Throwable? { get; }
           public final override val errno: kotlin.Int { get; }
           public open override val message: kotlin.String? { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public final override fun getStackTrace(): kotlin.Array<kotlin.String>

           public open override fun hashCode(): kotlin.Int

           public final override fun printStackTrace(): kotlin.Unit

           public open override fun toString(): kotlin.String

           public constructor InterruptedException(message: kotlin.String)

       }

       public final class InvalidArgumentException : kotlinx.io.errors.PosixException
       {
           public open override val cause: kotlin.Throwable? { get; }
           public final override val errno: kotlin.Int { get; }
           public open override val message: kotlin.String? { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public final override fun getStackTrace(): kotlin.Array<kotlin.String>

           public open override fun hashCode(): kotlin.Int

           public final override fun printStackTrace(): kotlin.Unit

           public open override fun toString(): kotlin.String

           public constructor InvalidArgumentException(message: kotlin.String)

       }

       public final class NoMemoryException : kotlinx.io.errors.PosixException
       {
           public open override val cause: kotlin.Throwable? { get; }
           public final override val errno: kotlin.Int { get; }
           public open override val message: kotlin.String? { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public final override fun getStackTrace(): kotlin.Array<kotlin.String>

           public open override fun hashCode(): kotlin.Int

           public final override fun printStackTrace(): kotlin.Unit

           public open override fun toString(): kotlin.String

           public constructor NoMemoryException(message: kotlin.String)

       }

       public final class NoSuchFileException : kotlinx.io.errors.PosixException
       {
           public open override val cause: kotlin.Throwable? { get; }
           public final override val errno: kotlin.Int { get; }
           public open override val message: kotlin.String? { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public final override fun getStackTrace(): kotlin.Array<kotlin.String>

           public open override fun hashCode(): kotlin.Int

           public final override fun printStackTrace(): kotlin.Unit

           public open override fun toString(): kotlin.String

           public constructor NoSuchFileException(message: kotlin.String)

       }

       public final class NotConnectedException : kotlinx.io.errors.PosixException
       {
           public open override val cause: kotlin.Throwable? { get; }
           public final override val errno: kotlin.Int { get; }
           public open override val message: kotlin.String? { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public final override fun getStackTrace(): kotlin.Array<kotlin.String>

           public open override fun hashCode(): kotlin.Int

           public final override fun printStackTrace(): kotlin.Unit

           public open override fun toString(): kotlin.String

           public constructor NotConnectedException(message: kotlin.String)

       }

       public final class NotSocketException : kotlinx.io.errors.PosixException
       {
           public open override val cause: kotlin.Throwable? { get; }
           public final override val errno: kotlin.Int { get; }
           public open override val message: kotlin.String? { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public final override fun getStackTrace(): kotlin.Array<kotlin.String>

           public open override fun hashCode(): kotlin.Int

           public final override fun printStackTrace(): kotlin.Unit

           public open override fun toString(): kotlin.String

           public constructor NotSocketException(message: kotlin.String)

       }

       public final class OverflowException : kotlinx.io.errors.PosixException
       {
           public open override val cause: kotlin.Throwable? { get; }
           public final override val errno: kotlin.Int { get; }
           public open override val message: kotlin.String? { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public final override fun getStackTrace(): kotlin.Array<kotlin.String>

           public open override fun hashCode(): kotlin.Int

           public final override fun printStackTrace(): kotlin.Unit

           public open override fun toString(): kotlin.String

           public constructor OverflowException(message: kotlin.String)

       }

       public final class PosixErrnoException : kotlinx.io.errors.PosixException
       {
           public open override val cause: kotlin.Throwable? { get; }
           public final override val errno: kotlin.Int { get; }
           public open override val message: kotlin.String? { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public final override fun getStackTrace(): kotlin.Array<kotlin.String>

           public open override fun hashCode(): kotlin.Int

           public final override fun printStackTrace(): kotlin.Unit

           public open override fun toString(): kotlin.String

           public constructor PosixErrnoException(errno: kotlin.Int, message: kotlin.String)

       }

       public final class TimeoutIOException : kotlinx.io.errors.PosixException
       {
           public open override val cause: kotlin.Throwable? { get; }
           public final override val errno: kotlin.Int { get; }
           public open override val message: kotlin.String? { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public final override fun getStackTrace(): kotlin.Array<kotlin.String>

           public open override fun hashCode(): kotlin.Int

           public final override fun printStackTrace(): kotlin.Unit

           public open override fun toString(): kotlin.String

           public constructor TimeoutIOException(message: kotlin.String)

       }

       public final class TryAgainException : kotlinx.io.errors.PosixException
       {
           public open override val cause: kotlin.Throwable? { get; }
           public final override val errno: kotlin.Int { get; }
           public open override val message: kotlin.String? { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public final override fun getStackTrace(): kotlin.Array<kotlin.String>

           public open override fun hashCode(): kotlin.Int

           public final override fun printStackTrace(): kotlin.Unit

           public open override fun toString(): kotlin.String

           public constructor TryAgainException(errno: kotlin.Int = ..., message: kotlin.String)

       }

   }

   public fun TODO_ERROR(): kotlin.Nothing

   public fun <R> TODO_ERROR(value: R): kotlin.Nothing

}

package kotlinx.io.bits
{
   public final class Memory
   {
       public final val pointer: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */> { get; }
       public final val size: kotlin.Long { get; }
       public final val size32: kotlin.Int { get; }
       public final fun copyTo(destination: kotlinx.io.bits.Memory, offset: kotlin.Int, length: kotlin.Int, destinationOffset: kotlin.Int): kotlin.Unit

       public final fun copyTo(destination: kotlinx.io.bits.Memory, offset: kotlin.Long, length: kotlin.Long, destinationOffset: kotlin.Long): kotlin.Unit

       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public open override fun hashCode(): kotlin.Int

       public final inline fun loadAt(index: kotlin.Int): kotlin.Byte

       public final inline fun loadAt(index: kotlin.Long): kotlin.Byte

       public final fun slice(offset: kotlin.Int, length: kotlin.Int): kotlinx.io.bits.Memory

       public final fun slice(offset: kotlin.Long, length: kotlin.Long): kotlinx.io.bits.Memory

       public final inline fun storeAt(index: kotlin.Int, value: kotlin.Byte): kotlin.Unit

       public final inline fun storeAt(index: kotlin.Long, value: kotlin.Byte): kotlin.Unit

       public open override fun toString(): kotlin.String

       public companion object of Memory
       {
           public final val Empty: kotlinx.io.bits.Memory { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public open override fun hashCode(): kotlin.Int

           public open override fun toString(): kotlin.String

       }

       public constructor Memory(pointer: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, size: kotlin.Long)

   }

   public val kotlin.Short.highByte: kotlin.Byte { get; }
   public val kotlin.Long.highInt: kotlin.Int { get; }
   public val kotlin.Int.highShort: kotlin.Short { get; }
   public val kotlin.Short.lowByte: kotlin.Byte { get; }
   public val kotlin.Long.lowInt: kotlin.Int { get; }
   public val kotlin.Int.lowShort: kotlin.Short { get; }
   public inline fun <R> withMemory(size: kotlin.Int, block: (kotlinx.io.bits.Memory) -> R): R

   public inline fun <R> withMemory(size: kotlin.Long, block: (kotlinx.io.bits.Memory) -> R): R

   public fun kotlinx.cinterop.NativePlacement.allocMemory(size: kotlin.Int): kotlinx.io.bits.Memory

   public fun kotlinx.cinterop.NativePlacement.allocMemory(size: kotlin.Long): kotlinx.io.bits.Memory

   public fun kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>.copyTo(destination: kotlinx.io.bits.Memory, offset: kotlin.Int, length: kotlin.Int, destinationOffset: kotlin.Int): kotlin.Unit

   public fun kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>.copyTo(destination: kotlinx.io.bits.Memory, offset: kotlin.Long, length: kotlin.Long, destinationOffset: kotlin.Long): kotlin.Unit

   public fun kotlinx.io.bits.Memory.copyTo(destination: kotlin.ByteArray, offset: kotlin.Int, length: kotlin.Int, destinationOffset: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.bits.Memory.copyTo(destination: kotlin.ByteArray, offset: kotlin.Long, length: kotlin.Int, destinationOffset: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.bits.Memory.copyTo(destination: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int, destinationOffset: kotlin.Int): kotlin.Unit

   public fun kotlinx.io.bits.Memory.copyTo(destination: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long, destinationOffset: kotlin.Long): kotlin.Unit

   public fun kotlinx.io.bits.Memory.fill(offset: kotlin.Int, count: kotlin.Int, value: kotlin.Byte): kotlin.Unit

   public fun kotlinx.io.bits.Memory.fill(offset: kotlin.Long, count: kotlin.Long, value: kotlin.Byte): kotlin.Unit

   public fun kotlinx.cinterop.NativeFreeablePlacement.free(memory: kotlinx.io.bits.Memory): kotlin.Unit

   public inline operator fun kotlinx.io.bits.Memory.get(index: kotlin.Int): kotlin.Byte

   public inline operator fun kotlinx.io.bits.Memory.get(index: kotlin.Long): kotlin.Byte

   public inline fun kotlinx.io.bits.Memory.loadByteArray(offset: kotlin.Int, destination: kotlin.ByteArray, destinationOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.loadByteArray(offset: kotlin.Long, destination: kotlin.ByteArray, destinationOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.bits.Memory.loadDoubleArray(offset: kotlin.Int, destination: kotlin.DoubleArray, destinationOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.bits.Memory.loadDoubleArray(offset: kotlin.Long, destination: kotlin.DoubleArray, destinationOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.loadDoubleAt(offset: kotlin.Int): kotlin.Double

   public inline fun kotlinx.io.bits.Memory.loadDoubleAt(offset: kotlin.Long): kotlin.Double

   public fun kotlinx.io.bits.Memory.loadFloatArray(offset: kotlin.Int, destination: kotlin.FloatArray, destinationOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.bits.Memory.loadFloatArray(offset: kotlin.Long, destination: kotlin.FloatArray, destinationOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.loadFloatAt(offset: kotlin.Int): kotlin.Float

   public inline fun kotlinx.io.bits.Memory.loadFloatAt(offset: kotlin.Long): kotlin.Float

   public fun kotlinx.io.bits.Memory.loadIntArray(offset: kotlin.Int, destination: kotlin.IntArray, destinationOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.bits.Memory.loadIntArray(offset: kotlin.Long, destination: kotlin.IntArray, destinationOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.loadIntAt(offset: kotlin.Int): kotlin.Int

   public inline fun kotlinx.io.bits.Memory.loadIntAt(offset: kotlin.Long): kotlin.Int

   public fun kotlinx.io.bits.Memory.loadLongArray(offset: kotlin.Int, destination: kotlin.LongArray, destinationOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.bits.Memory.loadLongArray(offset: kotlin.Long, destination: kotlin.LongArray, destinationOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.loadLongAt(offset: kotlin.Int): kotlin.Long

   public inline fun kotlinx.io.bits.Memory.loadLongAt(offset: kotlin.Long): kotlin.Long

   public fun kotlinx.io.bits.Memory.loadShortArray(offset: kotlin.Int, destination: kotlin.ShortArray, destinationOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.bits.Memory.loadShortArray(offset: kotlin.Long, destination: kotlin.ShortArray, destinationOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.loadShortAt(offset: kotlin.Int): kotlin.Short

   public inline fun kotlinx.io.bits.Memory.loadShortAt(offset: kotlin.Long): kotlin.Short

   public inline fun kotlinx.io.bits.Memory.loadUByteArray(offset: kotlin.Int, destination: kotlin.UByteArray, destinationOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.loadUByteArray(offset: kotlin.Long, destination: kotlin.UByteArray, destinationOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.loadUIntArray(offset: kotlin.Int, destination: kotlin.UIntArray, destinationOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.loadUIntArray(offset: kotlin.Long, destination: kotlin.UIntArray, destinationOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.loadUIntAt(offset: kotlin.Int): kotlin.UInt

   public inline fun kotlinx.io.bits.Memory.loadUIntAt(offset: kotlin.Long): kotlin.UInt

   public inline fun kotlinx.io.bits.Memory.loadULongArray(offset: kotlin.Int, destination: kotlin.ULongArray, destinationOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.loadULongArray(offset: kotlin.Long, destination: kotlin.ULongArray, destinationOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.loadULongAt(offset: kotlin.Int): kotlin.ULong

   public inline fun kotlinx.io.bits.Memory.loadULongAt(offset: kotlin.Long): kotlin.ULong

   public inline fun kotlinx.io.bits.Memory.loadUShortArray(offset: kotlin.Int, destination: kotlin.UShortArray, destinationOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.loadUShortArray(offset: kotlin.Long, destination: kotlin.UShortArray, destinationOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.loadUShortAt(offset: kotlin.Int): kotlin.UShort

   public inline fun kotlinx.io.bits.Memory.loadUShortAt(offset: kotlin.Long): kotlin.UShort

   public inline fun kotlinx.io.bits.Memory.Companion.of(pointer: kotlinx.cinterop.CPointer<*>, size: kotlin.Int): kotlinx.io.bits.Memory

   public inline fun kotlinx.io.bits.Memory.Companion.of(pointer: kotlinx.cinterop.CPointer<*>, size: kotlin.Long): kotlinx.io.bits.Memory

   public inline fun kotlinx.io.bits.Memory.Companion.of(pointer: kotlinx.cinterop.CPointer<*>, size: platform.posix.size_t /* = kotlin.ULong */): kotlinx.io.bits.Memory

   public fun kotlin.Double.reverseByteOrder(): kotlin.Double

   public fun kotlin.Float.reverseByteOrder(): kotlin.Float

   public fun kotlin.Int.reverseByteOrder(): kotlin.Int

   public fun kotlin.Long.reverseByteOrder(): kotlin.Long

   public fun kotlin.Short.reverseByteOrder(): kotlin.Short

   public fun kotlin.UInt.reverseByteOrder(): kotlin.UInt

   public fun kotlin.ULong.reverseByteOrder(): kotlin.ULong

   public fun kotlin.UShort.reverseByteOrder(): kotlin.UShort

   public inline operator fun kotlinx.io.bits.Memory.set(index: kotlin.Int, value: kotlin.Byte): kotlin.Unit

   public inline operator fun kotlinx.io.bits.Memory.set(index: kotlin.Long, value: kotlin.Byte): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeAt(index: kotlin.Int, value: kotlin.UByte): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeAt(index: kotlin.Long, value: kotlin.UByte): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeByteArray(offset: kotlin.Int, source: kotlin.ByteArray, sourceOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeByteArray(offset: kotlin.Long, source: kotlin.ByteArray, sourceOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.bits.Memory.storeDoubleArray(offset: kotlin.Int, source: kotlin.DoubleArray, sourceOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.bits.Memory.storeDoubleArray(offset: kotlin.Long, source: kotlin.DoubleArray, sourceOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeDoubleAt(offset: kotlin.Int, value: kotlin.Double): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeDoubleAt(offset: kotlin.Long, value: kotlin.Double): kotlin.Unit

   public fun kotlinx.io.bits.Memory.storeFloatArray(offset: kotlin.Int, source: kotlin.FloatArray, sourceOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.bits.Memory.storeFloatArray(offset: kotlin.Long, source: kotlin.FloatArray, sourceOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeFloatAt(offset: kotlin.Int, value: kotlin.Float): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeFloatAt(offset: kotlin.Long, value: kotlin.Float): kotlin.Unit

   public fun kotlinx.io.bits.Memory.storeIntArray(offset: kotlin.Int, source: kotlin.IntArray, sourceOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.bits.Memory.storeIntArray(offset: kotlin.Long, source: kotlin.IntArray, sourceOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeIntAt(offset: kotlin.Int, value: kotlin.Int): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeIntAt(offset: kotlin.Long, value: kotlin.Int): kotlin.Unit

   public fun kotlinx.io.bits.Memory.storeLongArray(offset: kotlin.Int, source: kotlin.LongArray, sourceOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.bits.Memory.storeLongArray(offset: kotlin.Long, source: kotlin.LongArray, sourceOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeLongAt(offset: kotlin.Int, value: kotlin.Long): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeLongAt(offset: kotlin.Long, value: kotlin.Long): kotlin.Unit

   public fun kotlinx.io.bits.Memory.storeShortArray(offset: kotlin.Int, source: kotlin.ShortArray, sourceOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.bits.Memory.storeShortArray(offset: kotlin.Long, source: kotlin.ShortArray, sourceOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeShortAt(offset: kotlin.Int, value: kotlin.Short): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeShortAt(offset: kotlin.Long, value: kotlin.Short): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeUByteArray(offset: kotlin.Int, source: kotlin.UByteArray, sourceOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeUByteArray(offset: kotlin.Long, source: kotlin.UByteArray, sourceOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeUIntArray(offset: kotlin.Int, source: kotlin.UIntArray, sourceOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeUIntArray(offset: kotlin.Long, source: kotlin.UIntArray, sourceOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeUIntAt(offset: kotlin.Int, value: kotlin.UInt): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeUIntAt(offset: kotlin.Long, value: kotlin.UInt): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeULongArray(offset: kotlin.Int, source: kotlin.ULongArray, sourceOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeULongArray(offset: kotlin.Long, source: kotlin.ULongArray, sourceOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeULongAt(offset: kotlin.Int, value: kotlin.ULong): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeULongAt(offset: kotlin.Long, value: kotlin.ULong): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeUShortArray(offset: kotlin.Int, source: kotlin.UShortArray, sourceOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeUShortArray(offset: kotlin.Long, source: kotlin.UShortArray, sourceOffset: kotlin.Int = ..., count: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeUShortAt(offset: kotlin.Int, value: kotlin.UShort): kotlin.Unit

   public inline fun kotlinx.io.bits.Memory.storeUShortAt(offset: kotlin.Long, value: kotlin.UShort): kotlin.Unit

   public inline fun <R> kotlin.ByteArray.useMemory(offset: kotlin.Int = ..., length: kotlin.Int, block: (kotlinx.io.bits.Memory) -> R): R

}

package kotlinx.io.charsets
{
   public abstract class Charset
   {
       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public open override fun hashCode(): kotlin.Int

       public abstract fun newDecoder(): kotlinx.io.charsets.CharsetDecoder

       public abstract fun newEncoder(): kotlinx.io.charsets.CharsetEncoder

       public open override fun toString(): kotlin.String

       public companion object of Charset
       {
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public final fun forName(name: kotlin.String): kotlinx.io.charsets.Charset

           public open override fun hashCode(): kotlin.Int

           public open override fun toString(): kotlin.String

       }

       public constructor Charset(_name: kotlin.String)

   }

   public abstract class CharsetDecoder
   {
       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public open override fun hashCode(): kotlin.Int

       public open override fun toString(): kotlin.String

       public constructor CharsetDecoder(_charset: kotlinx.io.charsets.Charset)

   }

   public abstract class CharsetEncoder
   {
       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public open override fun hashCode(): kotlin.Int

       public open override fun toString(): kotlin.String

       public constructor CharsetEncoder(_charset: kotlinx.io.charsets.Charset)

   }

   public object Charsets
   {
       public final val ISO_8859_1: kotlinx.io.charsets.Charset { get; }
       public final val UTF_8: kotlinx.io.charsets.Charset { get; }
       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public open override fun hashCode(): kotlin.Int

       public open override fun toString(): kotlin.String

   }

   public final class MalformedInputException : kotlin.Throwable
   {
       public open override val cause: kotlin.Throwable? { get; }
       public open override val message: kotlin.String? { get; }
       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public final override fun getStackTrace(): kotlin.Array<kotlin.String>

       public open override fun hashCode(): kotlin.Int

       public final override fun printStackTrace(): kotlin.Unit

       public open override fun toString(): kotlin.String

       public constructor MalformedInputException(message: kotlin.String)

   }

   public val kotlinx.io.charsets.CharsetDecoder.charset: kotlinx.io.charsets.Charset { get; }
   public val kotlinx.io.charsets.CharsetEncoder.charset: kotlinx.io.charsets.Charset { get; }
   public val kotlinx.io.charsets.Charset.name: kotlin.String { get; }
   public fun kotlinx.io.charsets.CharsetDecoder.decode(input: kotlinx.io.core.Input, max: kotlin.Int = ...): kotlin.String

   public fun kotlinx.io.charsets.CharsetDecoder.decode(input: kotlinx.io.core.Input, dst: kotlin.text.Appendable, max: kotlin.Int): kotlin.Int

   public fun kotlinx.io.charsets.CharsetDecoder.decodeExactBytes(input: kotlinx.io.core.Input, inputLength: kotlin.Int): kotlin.String

   public fun kotlinx.io.charsets.CharsetEncoder.encode(input: kotlin.CharArray, fromIndex: kotlin.Int, toIndex: kotlin.Int, dst: kotlinx.io.core.Output): kotlin.Unit

   public fun kotlinx.io.charsets.CharsetEncoder.encode(input: kotlin.CharSequence, fromIndex: kotlin.Int = ..., toIndex: kotlin.Int = ...): kotlinx.io.core.ByteReadPacket

   public fun kotlinx.io.charsets.CharsetEncoder.encode(input: kotlin.CharSequence, fromIndex: kotlin.Int, toIndex: kotlin.Int, dst: kotlinx.io.core.Output): kotlin.Unit

   public fun kotlinx.io.charsets.CharsetEncoder.encodeToByteArray(input: kotlin.CharSequence, fromIndex: kotlin.Int = ..., toIndex: kotlin.Int = ...): kotlin.ByteArray

   public fun kotlinx.io.charsets.CharsetEncoder.encodeToByteArrayImpl(input: kotlin.CharSequence, fromIndex: kotlin.Int = ..., toIndex: kotlin.Int = ...): kotlin.ByteArray

   public fun kotlinx.io.charsets.CharsetEncoder.encodeUTF8(input: kotlinx.io.core.ByteReadPacket): kotlinx.io.core.ByteReadPacket

   public fun kotlinx.io.charsets.CharsetEncoder.encodeUTF8(input: kotlinx.io.core.ByteReadPacket, dst: kotlinx.io.core.Output): kotlin.Unit

}

package kotlinx.io.core
{
   public abstract class AbstractInput : kotlinx.io.core.Input
   {
       public final override var byteOrder: kotlinx.io.core.ByteOrder { get; set; }
       public final override val endOfInput: kotlin.Boolean { get; }
       public final val isEmpty: kotlin.Boolean { get; }
       public final val isNotEmpty: kotlin.Boolean { get; }
       public final val pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer> { get; }
       public final val remaining: kotlin.Long { get; }
       public final fun canRead(): kotlin.Boolean

       public final override fun close(): kotlin.Unit

       protected abstract fun closeSource(): kotlin.Unit

       public final fun discard(n: kotlin.Int): kotlin.Int

       public final override fun discard(n: kotlin.Long): kotlin.Long

       public final fun discardExact(n: kotlin.Int): kotlin.Unit

       public final fun ensureNextHead(current: kotlinx.io.core.internal.ChunkBuffer): kotlinx.io.core.internal.ChunkBuffer?

       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       protected open fun fill(): kotlinx.io.core.internal.ChunkBuffer?

       protected abstract fun fill(destination: kotlinx.io.bits.Memory, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public final fun fixGapAfterRead(current: kotlinx.io.core.internal.ChunkBuffer): kotlin.Unit

       public final fun hasBytes(n: kotlin.Int): kotlin.Boolean

       public open override fun hashCode(): kotlin.Int

       protected final fun markNoMoreChunksAvailable(): kotlin.Unit

       public final override fun peekTo(destination: kotlinx.io.bits.Memory, destinationOffset: kotlin.Long, offset: kotlin.Long = ..., min: kotlin.Long = ..., max: kotlin.Long = ...): kotlin.Long

       public final override fun peekTo(buffer: kotlinx.io.core.IoBuffer): kotlin.Int

       public final fun prepareReadHead(minSize: kotlin.Int): kotlinx.io.core.internal.ChunkBuffer?

       public open override fun readAvailable(dst: kotlin.ByteArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlin.DoubleArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlin.FloatArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlin.IntArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlin.LongArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlin.ShortArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Long

       public open override fun readAvailable(dst: kotlinx.io.core.IoBuffer, length: kotlin.Int): kotlin.Int

       public final override fun readByte(): kotlin.Byte

       public final override fun readDouble(): kotlin.Double

       public final override fun readFloat(): kotlin.Float

       public final override fun readFully(dst: kotlin.ByteArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlin.DoubleArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlin.FloatArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlin.IntArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlin.LongArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlin.ShortArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Unit

       public open override fun readFully(dst: kotlinx.io.core.IoBuffer, length: kotlin.Int): kotlin.Unit

       public final override fun readInt(): kotlin.Int

       public final override fun readLong(): kotlin.Long

       public final override fun readShort(): kotlin.Short

       public final fun readText(min: kotlin.Int = ..., max: kotlin.Int = ...): kotlin.String

       public final fun readText(out: kotlin.text.Appendable, min: kotlin.Int = ..., max: kotlin.Int = ...): kotlin.Int

       public final fun readTextExact(exactCharacters: kotlin.Int): kotlin.String

       public final fun readTextExact(out: kotlin.text.Appendable, exactCharacters: kotlin.Int): kotlin.Unit

       public final fun release(): kotlin.Unit

       public open override fun toString(): kotlin.String

       public final override fun tryPeek(): kotlin.Int

       public final fun updateHeadRemaining(remaining: kotlin.Int): kotlin.Unit

       public companion object of AbstractInput
       {
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public open override fun hashCode(): kotlin.Int

           public open override fun toString(): kotlin.String

       }

       public constructor AbstractInput(head: kotlinx.io.core.IoBuffer = ..., remaining: kotlin.Long = ..., pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer> = ...)

       public constructor AbstractInput(head: kotlinx.io.core.internal.ChunkBuffer = ..., remaining: kotlin.Long = ..., pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer> = ...)

   }

   public abstract class AbstractOutput : kotlin.text.Appendable, kotlinx.io.core.Output
   {
       protected final var _size: kotlin.Int { get; set; }
       public final override var byteOrder: kotlinx.io.core.ByteOrder { get; set; }
       protected final var currentTail: kotlinx.io.core.internal.ChunkBuffer { get; set; }
       protected final val pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer> { get; }
       public final fun afterHeadWrite(): kotlin.Unit

       public open override fun append(c: kotlin.Char): kotlinx.io.core.AbstractOutput

       public open override fun append(csq: kotlin.CharArray, start: kotlin.Int, end: kotlin.Int): kotlin.text.Appendable

       public open override fun append(csq: kotlin.CharSequence?): kotlinx.io.core.AbstractOutput

       public open override fun append(csq: kotlin.CharSequence?, start: kotlin.Int, end: kotlin.Int): kotlinx.io.core.AbstractOutput

       public final fun appendNewBuffer(): kotlinx.io.core.IoBuffer

       public final override fun close(): kotlin.Unit

       protected abstract fun closeDestination(): kotlin.Unit

       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public open override fun fill(n: kotlin.Long, v: kotlin.Byte): kotlin.Unit

       public final override fun flush(): kotlin.Unit

       protected abstract fun flush(source: kotlinx.io.bits.Memory, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun hashCode(): kotlin.Int

       public final fun prepareWriteHead(n: kotlin.Int): kotlinx.io.core.internal.ChunkBuffer

       public final fun release(): kotlin.Unit

       public open fun reset(): kotlin.Unit

       public open override fun toString(): kotlin.String

       public final override fun writeByte(v: kotlin.Byte): kotlin.Unit

       public open override fun writeDouble(v: kotlin.Double): kotlin.Unit

       public open override fun writeFloat(v: kotlin.Float): kotlin.Unit

       public open override fun writeFully(src: kotlin.ByteArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlin.DoubleArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlin.FloatArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlin.IntArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlin.LongArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlin.ShortArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Unit

       public open override fun writeFully(src: kotlinx.io.core.IoBuffer, length: kotlin.Int): kotlin.Unit

       public open override fun writeInt(v: kotlin.Int): kotlin.Unit

       public open override fun writeLong(v: kotlin.Long): kotlin.Unit

       public final fun writePacket(p: kotlinx.io.core.ByteReadPacket): kotlin.Unit

       public final fun writePacket(p: kotlinx.io.core.ByteReadPacket, n: kotlin.Int): kotlin.Unit

       public final fun writePacket(p: kotlinx.io.core.ByteReadPacket, n: kotlin.Long): kotlin.Unit

       public open override fun writeShort(v: kotlin.Short): kotlin.Unit

       public final fun writeStringUtf8(cs: kotlin.CharSequence): kotlin.Unit

       public final fun writeStringUtf8(s: kotlin.String): kotlin.Unit

       public constructor AbstractOutput(pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer>)

       public constructor AbstractOutput()

   }

   public open class Buffer
   {
       public final var attachment: kotlin.Any? { get; set; }
       public final val capacity: kotlin.Int { get; }
       public final val endGap: kotlin.Int { get; }
       public final var limit: kotlin.Int { get; }
       public final val memory: kotlinx.io.bits.Memory { get; }
       public final var readPosition: kotlin.Int { get; }
       public final val readRemaining: kotlin.Int { get; }
       public final var startGap: kotlin.Int { get; }
       public final var writePosition: kotlin.Int { get; }
       public final val writeRemaining: kotlin.Int { get; }
       public final fun commitWritten(count: kotlin.Int): kotlin.Unit

       public final fun discard(count: kotlin.Int): kotlin.Int

       public final fun discard(count: kotlin.Long): kotlin.Long

       public final fun discardExact(count: kotlin.Int = ...): kotlin.Unit

       public open fun duplicate(): kotlinx.io.core.Buffer

       protected open fun duplicateTo(copy: kotlinx.io.core.Buffer): kotlin.Unit

       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public open override fun hashCode(): kotlin.Int

       public final fun readByte(): kotlin.Byte

       public final fun reserveEndGap(endGap: kotlin.Int): kotlin.Unit

       public final fun reserveStartGap(startGap: kotlin.Int): kotlin.Unit

       public open fun reset(): kotlin.Unit

       public final fun resetForRead(): kotlin.Unit

       public final fun resetForWrite(): kotlin.Unit

       public final fun resetForWrite(limit: kotlin.Int): kotlin.Unit

       public final fun rewind(count: kotlin.Int = ...): kotlin.Unit

       public open override fun toString(): kotlin.String

       public final fun tryPeekByte(): kotlin.Int

       public final fun tryReadByte(): kotlin.Int

       public final fun writeByte(value: kotlin.Byte): kotlin.Unit

       public companion object of Buffer
       {
           public final val Empty: kotlinx.io.core.Buffer { get; }
           public const final val ReservedSize: kotlin.Int = 8 { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public open override fun hashCode(): kotlin.Int

           public open override fun toString(): kotlin.String

       }

       public constructor Buffer(memory: kotlinx.io.bits.Memory)

   }

   public final class BufferLimitExceededException : kotlin.Exception
   {
       public open override val cause: kotlin.Throwable? { get; }
       public open override val message: kotlin.String? { get; }
       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public final override fun getStackTrace(): kotlin.Array<kotlin.String>

       public open override fun hashCode(): kotlin.Int

       public final override fun printStackTrace(): kotlin.Unit

       public open override fun toString(): kotlin.String

       public constructor BufferLimitExceededException(message: kotlin.String)

   }

   public final enum class ByteOrder : kotlin.Enum<kotlinx.io.core.ByteOrder>
   {
       enum entry BIG_ENDIAN

       enum entry LITTLE_ENDIAN

       public final override val name: kotlin.String { get; }
       public final override val ordinal: kotlin.Int { get; }
       public final override operator fun compareTo(other: kotlinx.io.core.ByteOrder): kotlin.Int

       public final override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public final override fun hashCode(): kotlin.Int

       public open override fun toString(): kotlin.String

       public companion object of ByteOrder
       {
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public open override fun hashCode(): kotlin.Int

           public final fun nativeOrder(): kotlinx.io.core.ByteOrder

           public open override fun toString(): kotlin.String

       }

   }

   public final class BytePacketBuilder : kotlinx.io.core.BytePacketBuilderPlatformBase
   {
       protected final override var _size: kotlin.Int { get; set; }
       public final override var byteOrder: kotlinx.io.core.ByteOrder { get; set; }
       protected final override var currentTail: kotlinx.io.core.internal.ChunkBuffer { get; set; }
       public final val isEmpty: kotlin.Boolean { get; }
       public final val isNotEmpty: kotlin.Boolean { get; }
       protected final override val pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer> { get; }
       public final val size: kotlin.Int { get; }
       public final override fun afterHeadWrite(): kotlin.Unit

       public open override fun append(c: kotlin.Char): kotlinx.io.core.BytePacketBuilder

       public open override fun append(csq: kotlin.CharSequence?): kotlinx.io.core.BytePacketBuilder

       public open override fun append(csq: kotlin.CharSequence?, start: kotlin.Int, end: kotlin.Int): kotlinx.io.core.BytePacketBuilder

       public open override fun append(csq: kotlin.CharArray, start: kotlin.Int, end: kotlin.Int): kotlin.text.Appendable

       public final override fun appendNewBuffer(): kotlinx.io.core.IoBuffer

       public final fun appendOld(c: kotlin.Char): kotlinx.io.core.BytePacketBuilderBase

       public final fun appendOld(csq: kotlin.CharSequence?): kotlinx.io.core.BytePacketBuilderBase

       public final fun appendOld(csq: kotlin.CharSequence?, start: kotlin.Int, end: kotlin.Int): kotlinx.io.core.BytePacketBuilderBase

       public final fun build(): kotlinx.io.core.ByteReadPacket

       public final override fun close(): kotlin.Unit

       protected final override fun closeDestination(): kotlin.Unit

       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public open override fun fill(n: kotlin.Long, v: kotlin.Byte): kotlin.Unit

       protected final override fun flush(source: kotlinx.io.bits.Memory, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public final override fun flush(): kotlin.Unit

       public open override fun hashCode(): kotlin.Int

       public final override fun prepareWriteHead(n: kotlin.Int): kotlinx.io.core.internal.ChunkBuffer

       public final fun <R> preview(block: (tmp: kotlinx.io.core.ByteReadPacket) -> R): R

       public final override fun release(): kotlin.Unit

       public final override fun reset(): kotlin.Unit

       public open override fun toString(): kotlin.String

       public final override fun writeByte(v: kotlin.Byte): kotlin.Unit

       public open override fun writeDouble(v: kotlin.Double): kotlin.Unit

       public open override fun writeFloat(v: kotlin.Float): kotlin.Unit

       public open override fun writeFully(src: kotlin.ByteArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlin.DoubleArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlin.FloatArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlin.IntArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlin.LongArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlin.ShortArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Unit

       public open override fun writeFully(src: kotlinx.io.core.IoBuffer, length: kotlin.Int): kotlin.Unit

       public open override fun writeInt(v: kotlin.Int): kotlin.Unit

       public open override fun writeLong(v: kotlin.Long): kotlin.Unit

       public final override fun writePacket(p: kotlinx.io.core.ByteReadPacket): kotlin.Unit

       public final override fun writePacket(p: kotlinx.io.core.ByteReadPacket, n: kotlin.Int): kotlin.Unit

       public final override fun writePacket(p: kotlinx.io.core.ByteReadPacket, n: kotlin.Long): kotlin.Unit

       public open override fun writeShort(v: kotlin.Short): kotlin.Unit

       public final override fun writeStringUtf8(cs: kotlin.CharSequence): kotlin.Unit

       public final override fun writeStringUtf8(s: kotlin.String): kotlin.Unit

       public constructor BytePacketBuilder(headerSizeHint: kotlin.Int = ..., pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer>)

   }

   public abstract class BytePacketBuilderBase : kotlinx.io.core.AbstractOutput
   {
       protected final override var _size: kotlin.Int { get; set; }
       public final override var byteOrder: kotlinx.io.core.ByteOrder { get; set; }
       protected final override var currentTail: kotlinx.io.core.internal.ChunkBuffer { get; set; }
       protected final override val pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer> { get; }
       public final override fun afterHeadWrite(): kotlin.Unit

       public open override fun append(c: kotlin.Char): kotlinx.io.core.AbstractOutput

       public open override fun append(csq: kotlin.CharArray, start: kotlin.Int, end: kotlin.Int): kotlin.text.Appendable

       public open override fun append(csq: kotlin.CharSequence?): kotlinx.io.core.AbstractOutput

       public open override fun append(csq: kotlin.CharSequence?, start: kotlin.Int, end: kotlin.Int): kotlinx.io.core.AbstractOutput

       public final override fun appendNewBuffer(): kotlinx.io.core.IoBuffer

       public final override fun close(): kotlin.Unit

       protected abstract override fun closeDestination(): kotlin.Unit

       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public open override fun fill(n: kotlin.Long, v: kotlin.Byte): kotlin.Unit

       public final override fun flush(): kotlin.Unit

       protected abstract override fun flush(source: kotlinx.io.bits.Memory, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun hashCode(): kotlin.Int

       public final override fun prepareWriteHead(n: kotlin.Int): kotlinx.io.core.internal.ChunkBuffer

       public final override fun release(): kotlin.Unit

       public open override fun reset(): kotlin.Unit

       public open override fun toString(): kotlin.String

       public final override fun writeByte(v: kotlin.Byte): kotlin.Unit

       public open override fun writeDouble(v: kotlin.Double): kotlin.Unit

       public open override fun writeFloat(v: kotlin.Float): kotlin.Unit

       public open override fun writeFully(src: kotlin.ByteArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlin.DoubleArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlin.FloatArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlin.IntArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlin.LongArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlin.ShortArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Unit

       public open override fun writeFully(src: kotlinx.io.core.IoBuffer, length: kotlin.Int): kotlin.Unit

       public open override fun writeInt(v: kotlin.Int): kotlin.Unit

       public open override fun writeLong(v: kotlin.Long): kotlin.Unit

       public final override fun writePacket(p: kotlinx.io.core.ByteReadPacket): kotlin.Unit

       public final override fun writePacket(p: kotlinx.io.core.ByteReadPacket, n: kotlin.Int): kotlin.Unit

       public final override fun writePacket(p: kotlinx.io.core.ByteReadPacket, n: kotlin.Long): kotlin.Unit

       public open override fun writeShort(v: kotlin.Short): kotlin.Unit

       public final override fun writeStringUtf8(cs: kotlin.CharSequence): kotlin.Unit

       public final override fun writeStringUtf8(s: kotlin.String): kotlin.Unit

   }

   public abstract class BytePacketBuilderPlatformBase : kotlinx.io.core.BytePacketBuilderBase
   {
       protected final override var _size: kotlin.Int { get; set; }
       public final override var byteOrder: kotlinx.io.core.ByteOrder { get; set; }
       protected final override var currentTail: kotlinx.io.core.internal.ChunkBuffer { get; set; }
       protected final override val pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer> { get; }
       public final override fun afterHeadWrite(): kotlin.Unit

       public open override fun append(c: kotlin.Char): kotlinx.io.core.AbstractOutput

       public open override fun append(csq: kotlin.CharArray, start: kotlin.Int, end: kotlin.Int): kotlin.text.Appendable

       public open override fun append(csq: kotlin.CharSequence?): kotlinx.io.core.AbstractOutput

       public open override fun append(csq: kotlin.CharSequence?, start: kotlin.Int, end: kotlin.Int): kotlinx.io.core.AbstractOutput

       public final override fun appendNewBuffer(): kotlinx.io.core.IoBuffer

       public final override fun close(): kotlin.Unit

       protected abstract override fun closeDestination(): kotlin.Unit

       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public open override fun fill(n: kotlin.Long, v: kotlin.Byte): kotlin.Unit

       public final override fun flush(): kotlin.Unit

       protected abstract override fun flush(source: kotlinx.io.bits.Memory, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun hashCode(): kotlin.Int

       public final override fun prepareWriteHead(n: kotlin.Int): kotlinx.io.core.internal.ChunkBuffer

       public final override fun release(): kotlin.Unit

       public open override fun reset(): kotlin.Unit

       public open override fun toString(): kotlin.String

       public final override fun writeByte(v: kotlin.Byte): kotlin.Unit

       public open override fun writeDouble(v: kotlin.Double): kotlin.Unit

       public open override fun writeFloat(v: kotlin.Float): kotlin.Unit

       public open override fun writeFully(src: kotlin.ByteArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlin.DoubleArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlin.FloatArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlin.IntArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlin.LongArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlin.ShortArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun writeFully(src: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Unit

       public open override fun writeFully(src: kotlinx.io.core.IoBuffer, length: kotlin.Int): kotlin.Unit

       public open override fun writeInt(v: kotlin.Int): kotlin.Unit

       public open override fun writeLong(v: kotlin.Long): kotlin.Unit

       public final override fun writePacket(p: kotlinx.io.core.ByteReadPacket): kotlin.Unit

       public final override fun writePacket(p: kotlinx.io.core.ByteReadPacket, n: kotlin.Int): kotlin.Unit

       public final override fun writePacket(p: kotlinx.io.core.ByteReadPacket, n: kotlin.Long): kotlin.Unit

       public open override fun writeShort(v: kotlin.Short): kotlin.Unit

       public final override fun writeStringUtf8(cs: kotlin.CharSequence): kotlin.Unit

       public final override fun writeStringUtf8(s: kotlin.String): kotlin.Unit

   }

   public final class ByteReadPacket : kotlinx.io.core.ByteReadPacketPlatformBase, kotlinx.io.core.Input
   {
       public final override var byteOrder: kotlinx.io.core.ByteOrder { get; set; }
       public final override val endOfInput: kotlin.Boolean { get; }
       public final override val isEmpty: kotlin.Boolean { get; }
       public final override val isNotEmpty: kotlin.Boolean { get; }
       public final override val pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer> { get; }
       public final override val remaining: kotlin.Long { get; }
       public final override fun canRead(): kotlin.Boolean

       public final override fun close(): kotlin.Unit

       protected final override fun closeSource(): kotlin.Unit

       public final fun copy(): kotlinx.io.core.ByteReadPacket

       public final override fun discard(n: kotlin.Int): kotlin.Int

       public final override fun discard(n: kotlin.Long): kotlin.Long

       public final override fun discardExact(n: kotlin.Int): kotlin.Unit

       public final override fun ensureNextHead(current: kotlinx.io.core.internal.ChunkBuffer): kotlinx.io.core.internal.ChunkBuffer?

       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       protected final override fun fill(): kotlin.Nothing?

       protected final override fun fill(destination: kotlinx.io.bits.Memory, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public final override fun fixGapAfterRead(current: kotlinx.io.core.internal.ChunkBuffer): kotlin.Unit

       public final override fun hasBytes(n: kotlin.Int): kotlin.Boolean

       public open override fun hashCode(): kotlin.Int

       protected final override fun markNoMoreChunksAvailable(): kotlin.Unit

       public final override fun peekTo(destination: kotlinx.io.bits.Memory, destinationOffset: kotlin.Long, offset: kotlin.Long = ..., min: kotlin.Long = ..., max: kotlin.Long = ...): kotlin.Long

       public final override fun peekTo(buffer: kotlinx.io.core.IoBuffer): kotlin.Int

       public final override fun prepareReadHead(minSize: kotlin.Int): kotlinx.io.core.internal.ChunkBuffer?

       public open override fun readAvailable(dst: kotlin.ByteArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlin.DoubleArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlin.FloatArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlin.IntArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlin.LongArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlin.ShortArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Long

       public open override fun readAvailable(dst: kotlinx.io.core.IoBuffer, length: kotlin.Int): kotlin.Int

       public final override fun readByte(): kotlin.Byte

       public final override fun readDouble(): kotlin.Double

       public final override fun readFloat(): kotlin.Float

       public final override fun readFully(dst: kotlin.ByteArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlin.DoubleArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlin.FloatArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlin.IntArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlin.LongArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlin.ShortArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Unit

       public open override fun readFully(dst: kotlinx.io.core.IoBuffer, length: kotlin.Int): kotlin.Unit

       public final override fun readInt(): kotlin.Int

       public final override fun readLong(): kotlin.Long

       public final override fun readShort(): kotlin.Short

       public final override fun readText(min: kotlin.Int = ..., max: kotlin.Int = ...): kotlin.String

       public final override fun readText(out: kotlin.text.Appendable, min: kotlin.Int = ..., max: kotlin.Int = ...): kotlin.Int

       public final override fun readTextExact(exactCharacters: kotlin.Int): kotlin.String

       public final override fun readTextExact(out: kotlin.text.Appendable, exactCharacters: kotlin.Int): kotlin.Unit

       public final override fun release(): kotlin.Unit

       public open override fun toString(): kotlin.String

       public final override fun tryPeek(): kotlin.Int

       public final override fun updateHeadRemaining(remaining: kotlin.Int): kotlin.Unit

       public companion object of ByteReadPacket
       {
           public final val Empty: kotlinx.io.core.ByteReadPacket { get; }
           public final val ReservedSize: kotlin.Int { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public open override fun hashCode(): kotlin.Int

           public open override fun toString(): kotlin.String

       }

       public constructor ByteReadPacket(head: kotlinx.io.core.internal.ChunkBuffer, pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer>)

       public constructor ByteReadPacket(head: kotlinx.io.core.IoBuffer, pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer>)

   }

   public abstract class ByteReadPacketBase : kotlinx.io.core.AbstractInput
   {
       public final override var byteOrder: kotlinx.io.core.ByteOrder { get; set; }
       public final override val endOfInput: kotlin.Boolean { get; }
       public final override val isEmpty: kotlin.Boolean { get; }
       public final override val isNotEmpty: kotlin.Boolean { get; }
       public final override val pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer> { get; }
       public final override val remaining: kotlin.Long { get; }
       public final override fun canRead(): kotlin.Boolean

       public final override fun close(): kotlin.Unit

       protected abstract override fun closeSource(): kotlin.Unit

       public final override fun discard(n: kotlin.Int): kotlin.Int

       public final override fun discard(n: kotlin.Long): kotlin.Long

       public final override fun discardExact(n: kotlin.Int): kotlin.Unit

       public final override fun ensureNextHead(current: kotlinx.io.core.internal.ChunkBuffer): kotlinx.io.core.internal.ChunkBuffer?

       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       protected open override fun fill(): kotlinx.io.core.internal.ChunkBuffer?

       protected abstract override fun fill(destination: kotlinx.io.bits.Memory, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public final override fun fixGapAfterRead(current: kotlinx.io.core.internal.ChunkBuffer): kotlin.Unit

       public final override fun hasBytes(n: kotlin.Int): kotlin.Boolean

       public open override fun hashCode(): kotlin.Int

       protected final override fun markNoMoreChunksAvailable(): kotlin.Unit

       public final override fun peekTo(destination: kotlinx.io.bits.Memory, destinationOffset: kotlin.Long, offset: kotlin.Long = ..., min: kotlin.Long = ..., max: kotlin.Long = ...): kotlin.Long

       public final override fun peekTo(buffer: kotlinx.io.core.IoBuffer): kotlin.Int

       public final override fun prepareReadHead(minSize: kotlin.Int): kotlinx.io.core.internal.ChunkBuffer?

       public open override fun readAvailable(dst: kotlin.ByteArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlin.DoubleArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlin.FloatArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlin.IntArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlin.LongArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlin.ShortArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Long

       public open override fun readAvailable(dst: kotlinx.io.core.IoBuffer, length: kotlin.Int): kotlin.Int

       public final override fun readByte(): kotlin.Byte

       public final override fun readDouble(): kotlin.Double

       public final override fun readFloat(): kotlin.Float

       public final override fun readFully(dst: kotlin.ByteArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlin.DoubleArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlin.FloatArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlin.IntArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlin.LongArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlin.ShortArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Unit

       public open override fun readFully(dst: kotlinx.io.core.IoBuffer, length: kotlin.Int): kotlin.Unit

       public final override fun readInt(): kotlin.Int

       public final override fun readLong(): kotlin.Long

       public final override fun readShort(): kotlin.Short

       public final override fun readText(min: kotlin.Int = ..., max: kotlin.Int = ...): kotlin.String

       public final override fun readText(out: kotlin.text.Appendable, min: kotlin.Int = ..., max: kotlin.Int = ...): kotlin.Int

       public final override fun readTextExact(exactCharacters: kotlin.Int): kotlin.String

       public final override fun readTextExact(out: kotlin.text.Appendable, exactCharacters: kotlin.Int): kotlin.Unit

       public final override fun release(): kotlin.Unit

       public open override fun toString(): kotlin.String

       public final override fun tryPeek(): kotlin.Int

       public final override fun updateHeadRemaining(remaining: kotlin.Int): kotlin.Unit

       public companion object of ByteReadPacketBase
       {
           public final val Empty: kotlinx.io.core.ByteReadPacket { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public open override fun hashCode(): kotlin.Int

           public open override fun toString(): kotlin.String

       }

       public constructor ByteReadPacketBase(head: kotlinx.io.core.IoBuffer, remaining: kotlin.Long, pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer>)

       public constructor ByteReadPacketBase(head: kotlinx.io.core.internal.ChunkBuffer, remaining: kotlin.Long, pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer>)

   }

   public abstract class ByteReadPacketPlatformBase : kotlinx.io.core.ByteReadPacketBase
   {
       public final override var byteOrder: kotlinx.io.core.ByteOrder { get; set; }
       public final override val endOfInput: kotlin.Boolean { get; }
       public final override val isEmpty: kotlin.Boolean { get; }
       public final override val isNotEmpty: kotlin.Boolean { get; }
       public final override val pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer> { get; }
       public final override val remaining: kotlin.Long { get; }
       public final override fun canRead(): kotlin.Boolean

       public final override fun close(): kotlin.Unit

       protected abstract override fun closeSource(): kotlin.Unit

       public final override fun discard(n: kotlin.Int): kotlin.Int

       public final override fun discard(n: kotlin.Long): kotlin.Long

       public final override fun discardExact(n: kotlin.Int): kotlin.Unit

       public final override fun ensureNextHead(current: kotlinx.io.core.internal.ChunkBuffer): kotlinx.io.core.internal.ChunkBuffer?

       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       protected open override fun fill(): kotlinx.io.core.internal.ChunkBuffer?

       protected abstract override fun fill(destination: kotlinx.io.bits.Memory, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public final override fun fixGapAfterRead(current: kotlinx.io.core.internal.ChunkBuffer): kotlin.Unit

       public final override fun hasBytes(n: kotlin.Int): kotlin.Boolean

       public open override fun hashCode(): kotlin.Int

       protected final override fun markNoMoreChunksAvailable(): kotlin.Unit

       public final override fun peekTo(destination: kotlinx.io.bits.Memory, destinationOffset: kotlin.Long, offset: kotlin.Long = ..., min: kotlin.Long = ..., max: kotlin.Long = ...): kotlin.Long

       public final override fun peekTo(buffer: kotlinx.io.core.IoBuffer): kotlin.Int

       public final override fun prepareReadHead(minSize: kotlin.Int): kotlinx.io.core.internal.ChunkBuffer?

       public open override fun readAvailable(dst: kotlin.ByteArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlin.DoubleArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlin.FloatArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlin.IntArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlin.LongArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlin.ShortArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open override fun readAvailable(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Long

       public open override fun readAvailable(dst: kotlinx.io.core.IoBuffer, length: kotlin.Int): kotlin.Int

       public final override fun readByte(): kotlin.Byte

       public final override fun readDouble(): kotlin.Double

       public final override fun readFloat(): kotlin.Float

       public final override fun readFully(dst: kotlin.ByteArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlin.DoubleArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlin.FloatArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlin.IntArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlin.LongArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlin.ShortArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open override fun readFully(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Unit

       public open override fun readFully(dst: kotlinx.io.core.IoBuffer, length: kotlin.Int): kotlin.Unit

       public final override fun readInt(): kotlin.Int

       public final override fun readLong(): kotlin.Long

       public final override fun readShort(): kotlin.Short

       public final override fun readText(min: kotlin.Int = ..., max: kotlin.Int = ...): kotlin.String

       public final override fun readText(out: kotlin.text.Appendable, min: kotlin.Int = ..., max: kotlin.Int = ...): kotlin.Int

       public final override fun readTextExact(exactCharacters: kotlin.Int): kotlin.String

       public final override fun readTextExact(out: kotlin.text.Appendable, exactCharacters: kotlin.Int): kotlin.Unit

       public final override fun release(): kotlin.Unit

       public open override fun toString(): kotlin.String

       public final override fun tryPeek(): kotlin.Int

       public final override fun updateHeadRemaining(remaining: kotlin.Int): kotlin.Unit

       public constructor ByteReadPacketPlatformBase(head: kotlinx.io.core.IoBuffer, remaining: kotlin.Long, pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer>)

       protected constructor ByteReadPacketPlatformBase(head: kotlinx.io.core.internal.ChunkBuffer, remaining: kotlin.Long, pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer>)

   }

   public interface Closeable
   {
       public abstract fun close(): kotlin.Unit

       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public open override fun hashCode(): kotlin.Int

       public open override fun toString(): kotlin.String

   }

   public final annotation class ExperimentalIoApi : kotlin.Annotation
   {
       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public open override fun hashCode(): kotlin.Int

       public open override fun toString(): kotlin.String

       public constructor ExperimentalIoApi()

   }

   public interface Input : kotlinx.io.core.Closeable
   {
       public abstract var byteOrder: kotlinx.io.core.ByteOrder { get; set; }
       public abstract val endOfInput: kotlin.Boolean { get; }
       public abstract override fun close(): kotlin.Unit

       public abstract fun discard(n: kotlin.Long): kotlin.Long

       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public open override fun hashCode(): kotlin.Int

       public abstract fun peekTo(destination: kotlinx.io.bits.Memory, destinationOffset: kotlin.Long, offset: kotlin.Long = ..., min: kotlin.Long = ..., max: kotlin.Long = ...): kotlin.Long

       public open fun peekTo(buffer: kotlinx.io.core.IoBuffer): kotlin.Int

       public open fun readAvailable(dst: kotlin.ByteArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open fun readAvailable(dst: kotlin.DoubleArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open fun readAvailable(dst: kotlin.FloatArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open fun readAvailable(dst: kotlin.IntArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open fun readAvailable(dst: kotlin.LongArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open fun readAvailable(dst: kotlin.ShortArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open fun readAvailable(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public open fun readAvailable(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Long

       public open fun readAvailable(dst: kotlinx.io.core.IoBuffer, length: kotlin.Int): kotlin.Int

       public abstract fun readByte(): kotlin.Byte

       public open fun readDouble(): kotlin.Double

       public open fun readFloat(): kotlin.Float

       public open fun readFully(dst: kotlin.ByteArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open fun readFully(dst: kotlin.DoubleArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open fun readFully(dst: kotlin.FloatArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open fun readFully(dst: kotlin.IntArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open fun readFully(dst: kotlin.LongArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open fun readFully(dst: kotlin.ShortArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open fun readFully(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open fun readFully(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Unit

       public open fun readFully(dst: kotlinx.io.core.IoBuffer, length: kotlin.Int): kotlin.Unit

       public open fun readInt(): kotlin.Int

       public open fun readLong(): kotlin.Long

       public open fun readShort(): kotlin.Short

       public open override fun toString(): kotlin.String

       public abstract fun tryPeek(): kotlin.Int

   }

   public final class InsufficientSpaceException : kotlin.Exception
   {
       public open override val cause: kotlin.Throwable? { get; }
       public open override val message: kotlin.String? { get; }
       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public final override fun getStackTrace(): kotlin.Array<kotlin.String>

       public open override fun hashCode(): kotlin.Int

       public final override fun printStackTrace(): kotlin.Unit

       public open override fun toString(): kotlin.String

       public constructor InsufficientSpaceException(size: kotlin.Int, availableSpace: kotlin.Int)

       public constructor InsufficientSpaceException(name: kotlin.String, size: kotlin.Int, availableSpace: kotlin.Int)

       public constructor InsufficientSpaceException(size: kotlin.Long, availableSpace: kotlin.Long)

       public constructor InsufficientSpaceException(message: kotlin.String = ...)

   }

   public final class IoBuffer : kotlinx.io.core.Input, kotlinx.io.core.Output, kotlinx.io.core.internal.ChunkBuffer
   {
       public final override var attachment: kotlin.Any? { get; set; }
       public final override var byteOrder: kotlinx.io.core.ByteOrder { get; set; }
       public final override val capacity: kotlin.Int { get; }
       public final override val endGap: kotlin.Int { get; }
       public open override val endOfInput: kotlin.Boolean { get; }
       public final override var limit: kotlin.Int { get; }
       public final override val memory: kotlinx.io.bits.Memory { get; }
       public final override var next: kotlinx.io.core.internal.ChunkBuffer? { get; set; }
       public final override var origin: kotlinx.io.core.internal.ChunkBuffer? { get; }
       public final override var readPosition: kotlin.Int { get; }
       public final override val readRemaining: kotlin.Int { get; }
       public final override val referenceCount: kotlin.Int { get; }
       public final override var startGap: kotlin.Int { get; }
       public final override var writePosition: kotlin.Int { get; }
       public final override val writeRemaining: kotlin.Int { get; }
       public open override fun append(c: kotlin.Char): kotlin.text.Appendable

       public final override fun append(csq: kotlin.CharArray, start: kotlin.Int, end: kotlin.Int): kotlin.text.Appendable

       public final override fun append(csq: kotlin.CharSequence?): kotlin.text.Appendable

       public final override fun append(csq: kotlin.CharSequence?, start: kotlin.Int, end: kotlin.Int): kotlin.text.Appendable

       public final fun appendChars(csq: kotlin.CharArray, start: kotlin.Int, end: kotlin.Int): kotlin.Int

       public final fun appendChars(csq: kotlin.CharSequence, start: kotlin.Int, end: kotlin.Int): kotlin.Int

       public final override fun cleanNext(): kotlinx.io.core.internal.ChunkBuffer?

       public open override fun close(): kotlin.Unit

       public final override fun commitWritten(count: kotlin.Int): kotlin.Unit

       public final override fun discard(n: kotlin.Long): kotlin.Long

       public final override fun discard(count: kotlin.Int): kotlin.Int

       public final override fun discardExact(count: kotlin.Int = ...): kotlin.Unit

       public open override fun duplicate(): kotlinx.io.core.IoBuffer

       protected open override fun duplicateTo(copy: kotlinx.io.core.Buffer): kotlin.Unit

       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public final override fun fill(n: kotlin.Long, v: kotlin.Byte): kotlin.Unit

       public final override fun flush(): kotlin.Unit

       public open override fun hashCode(): kotlin.Int

       public final fun makeView(): kotlinx.io.core.IoBuffer

       public final override fun peekTo(destination: kotlinx.io.bits.Memory, destinationOffset: kotlin.Long, offset: kotlin.Long = ..., min: kotlin.Long = ..., max: kotlin.Long = ...): kotlin.Long

       public final override fun peekTo(buffer: kotlinx.io.core.IoBuffer): kotlin.Int

       public final override fun readAvailable(dst: kotlin.ByteArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public final override fun readAvailable(dst: kotlin.DoubleArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public final override fun readAvailable(dst: kotlin.FloatArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public final override fun readAvailable(dst: kotlin.IntArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public final override fun readAvailable(dst: kotlin.LongArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public final override fun readAvailable(dst: kotlin.ShortArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public final override fun readAvailable(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

       public final override fun readAvailable(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Long

       public final override fun readAvailable(dst: kotlinx.io.core.IoBuffer, length: kotlin.Int): kotlin.Int

       public final override fun readByte(): kotlin.Byte

       public final fun readDirect(block: (kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>) -> kotlin.Int): kotlin.Int

       public final override fun readDouble(): kotlin.Double

       public final override fun readFloat(): kotlin.Float

       public final override fun readFully(dst: kotlin.ByteArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public final override fun readFully(dst: kotlin.DoubleArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public final override fun readFully(dst: kotlin.FloatArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public final override fun readFully(dst: kotlin.IntArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public final override fun readFully(dst: kotlin.LongArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public final override fun readFully(dst: kotlin.ShortArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public final override fun readFully(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public final override fun readFully(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Unit

       public final override fun readFully(dst: kotlinx.io.core.IoBuffer, length: kotlin.Int): kotlin.Unit

       public final override fun readInt(): kotlin.Int

       public final override fun readLong(): kotlin.Long

       public final override fun readShort(): kotlin.Short

       public final fun release(pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.IoBuffer>): kotlin.Unit

       public open override fun release(pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer>): kotlin.Unit

       public final override fun reserveEndGap(endGap: kotlin.Int): kotlin.Unit

       public final override fun reserveStartGap(startGap: kotlin.Int): kotlin.Unit

       public final override fun reset(): kotlin.Unit

       public final override fun resetForRead(): kotlin.Unit

       public final override fun resetForWrite(): kotlin.Unit

       public final override fun resetForWrite(limit: kotlin.Int): kotlin.Unit

       public final override fun rewind(count: kotlin.Int = ...): kotlin.Unit

       public open override fun toString(): kotlin.String

       public final override fun tryPeek(): kotlin.Int

       public final override fun tryPeekByte(): kotlin.Int

       public final override fun tryReadByte(): kotlin.Int

       public final override fun writeByte(v: kotlin.Byte): kotlin.Unit

       public final fun writeDirect(block: (kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>) -> kotlin.Int): kotlin.Int

       public final override fun writeDouble(v: kotlin.Double): kotlin.Unit

       public final override fun writeFloat(v: kotlin.Float): kotlin.Unit

       public final override fun writeFully(src: kotlin.ByteArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public final override fun writeFully(src: kotlin.DoubleArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public final override fun writeFully(src: kotlin.FloatArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public final override fun writeFully(src: kotlin.IntArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public final override fun writeFully(src: kotlin.LongArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public final override fun writeFully(src: kotlin.ShortArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public final override fun writeFully(src: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public final override fun writeFully(src: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Unit

       public final override fun writeFully(src: kotlinx.io.core.IoBuffer, length: kotlin.Int): kotlin.Unit

       public final override fun writeInt(v: kotlin.Int): kotlin.Unit

       public final override fun writeLong(v: kotlin.Long): kotlin.Unit

       public final override fun writeShort(v: kotlin.Short): kotlin.Unit

       public companion object of IoBuffer
       {
           public final val Empty: kotlinx.io.core.IoBuffer { get; }
           public final val EmptyPool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.IoBuffer> { get; }
           public final val NoPool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.IoBuffer> { get; }
           public final val Pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.IoBuffer> { get; }
           public final val ReservedSize: kotlin.Int { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public open override fun hashCode(): kotlin.Int

           public open override fun toString(): kotlin.String

       }

       public constructor IoBuffer(content: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, contentCapacity: kotlin.Int)

       public constructor IoBuffer(memory: kotlinx.io.bits.Memory, origin: kotlinx.io.core.internal.ChunkBuffer?)

   }

   public interface Output : kotlin.text.Appendable, kotlinx.io.core.Closeable
   {
       public abstract var byteOrder: kotlinx.io.core.ByteOrder { get; set; }
       public abstract fun append(csq: kotlin.CharArray, start: kotlin.Int, end: kotlin.Int): kotlin.text.Appendable

       public abstract override fun append(c: kotlin.Char): kotlin.text.Appendable

       public abstract override fun append(csq: kotlin.CharSequence?): kotlin.text.Appendable

       public abstract override fun append(csq: kotlin.CharSequence?, start: kotlin.Int, end: kotlin.Int): kotlin.text.Appendable

       public abstract override fun close(): kotlin.Unit

       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public open fun fill(n: kotlin.Long, v: kotlin.Byte): kotlin.Unit

       public abstract fun flush(): kotlin.Unit

       public open override fun hashCode(): kotlin.Int

       public open override fun toString(): kotlin.String

       public abstract fun writeByte(v: kotlin.Byte): kotlin.Unit

       public open fun writeDouble(v: kotlin.Double): kotlin.Unit

       public open fun writeFloat(v: kotlin.Float): kotlin.Unit

       public open fun writeFully(src: kotlin.ByteArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open fun writeFully(src: kotlin.DoubleArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open fun writeFully(src: kotlin.FloatArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open fun writeFully(src: kotlin.IntArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open fun writeFully(src: kotlin.LongArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open fun writeFully(src: kotlin.ShortArray, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open fun writeFully(src: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

       public open fun writeFully(src: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Unit

       public open fun writeFully(src: kotlinx.io.core.IoBuffer, length: kotlin.Int): kotlin.Unit

       public open fun writeInt(v: kotlin.Int): kotlin.Unit

       public open fun writeLong(v: kotlin.Long): kotlin.Unit

       public open fun writeShort(v: kotlin.Short): kotlin.Unit

   }

   public typealias EOFException = kotlinx.io.errors.EOFException
   public val PACKET_MAX_COPY_SIZE: kotlin.Int = 200 { get; }
   public var kotlinx.io.core.Buffer.byteOrder: kotlinx.io.core.ByteOrder { get; set; }
   public val kotlinx.io.core.ByteReadPacket.isEmpty: kotlin.Boolean { get; }
   public val kotlinx.io.core.Input.isEmpty: kotlin.Boolean { get; }
   public val kotlinx.io.core.ByteReadPacket.isNotEmpty: kotlin.Boolean { get; }
   public val kotlinx.io.core.Input.isNotEmpty: kotlin.Boolean { get; }
   public fun BytePacketBuilder(headerSizeHint: kotlin.Int = ...): kotlinx.io.core.BytePacketBuilder

   public inline fun ByteReadPacket(array: kotlin.ByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlinx.io.core.ByteReadPacket

   public fun ByteReadPacket(array: kotlin.ByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ..., block: (kotlin.ByteArray) -> kotlin.Unit): kotlinx.io.core.ByteReadPacket

   public fun ChunkBuffer(ptr: kotlinx.cinterop.CPointer<*>, lengthInBytes: kotlin.Int, origin: kotlinx.io.core.internal.ChunkBuffer?): kotlinx.io.core.internal.ChunkBuffer

   public fun ChunkBuffer(ptr: kotlinx.cinterop.CPointer<*>, lengthInBytes: kotlin.Long, origin: kotlinx.io.core.internal.ChunkBuffer?): kotlinx.io.core.internal.ChunkBuffer

   public fun String(bytes: kotlin.ByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ..., charset: kotlinx.io.charsets.Charset = ...): kotlin.String

   public inline fun buildPacket(headerSizeHint: kotlin.Int = ..., block: kotlinx.io.core.BytePacketBuilder.() -> kotlin.Unit): kotlinx.io.core.ByteReadPacket

   public fun remainingAll(buffer: kotlinx.io.core.IoBuffer): kotlin.Long

   public inline fun <R> withBuffer(size: kotlin.Int, block: kotlinx.io.core.Buffer.() -> R): R

   public inline fun <R> withBuffer(pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.Buffer>, block: kotlinx.io.core.Buffer.() -> R): R

   public fun kotlinx.io.core.Buffer.append(c: kotlin.Char): kotlinx.io.core.Buffer

   public fun kotlinx.io.core.Buffer.append(csq: kotlin.CharArray, start: kotlin.Int, end: kotlin.Int): kotlinx.io.core.Buffer

   public fun kotlinx.io.core.Buffer.append(csq: kotlin.CharSequence?): kotlinx.io.core.Buffer

   public fun kotlinx.io.core.Buffer.append(csq: kotlin.CharSequence?, start: kotlin.Int, end: kotlin.Int): kotlinx.io.core.Buffer

   public fun kotlinx.io.core.Output.append(csq: kotlin.CharArray, start: kotlin.Int = ..., end: kotlin.Int = ...): kotlin.text.Appendable

   public fun kotlinx.io.core.Output.append(csq: kotlin.CharSequence, start: kotlin.Int = ..., end: kotlin.Int = ...): kotlin.text.Appendable

   public inline fun kotlinx.io.core.Buffer.canRead(): kotlin.Boolean

   public inline fun kotlinx.io.core.Buffer.canWrite(): kotlin.Boolean

   public fun kotlinx.io.core.Input.copyTo(output: kotlinx.io.core.Output): kotlin.Long

   public fun kotlinx.io.core.Input.discard(): kotlin.Long

   public fun kotlinx.io.core.Input.discardExact(n: kotlin.Int): kotlin.Unit

   public fun kotlinx.io.core.Input.discardExact(n: kotlin.Long): kotlin.Unit

   public fun kotlinx.io.core.Input.discardUntilDelimiter(delimiter: kotlin.Byte): kotlin.Long

   public fun kotlinx.io.core.Input.discardUntilDelimiters(delimiter1: kotlin.Byte, delimiter2: kotlin.Byte): kotlin.Long

   public fun kotlinx.io.core.Buffer.fill(times: kotlin.Int, value: kotlin.Byte): kotlin.Unit

   public fun kotlinx.io.core.Buffer.fill(times: kotlin.Int, value: kotlin.UByte): kotlin.Unit

   public fun kotlinx.io.core.Buffer.fill(n: kotlin.Long, v: kotlin.Byte): kotlin.Unit

   public fun kotlinx.io.core.Output.fill(times: kotlin.Long, value: kotlin.Byte = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.flush(): kotlin.Unit

   public inline fun kotlinx.io.core.Buffer.forEach(block: (kotlin.Byte) -> kotlin.Unit): kotlin.Unit

   public inline fun kotlinx.io.core.Input.forEach(block: (kotlin.Byte) -> kotlin.Unit): kotlin.Unit

   public fun kotlinx.io.core.Buffer.makeView(): kotlinx.io.core.Buffer

   public fun kotlinx.io.core.internal.ChunkBuffer.makeView(): kotlinx.io.core.internal.ChunkBuffer

   public fun kotlinx.io.core.Input.peekCharUtf8(): kotlin.Char

   public fun kotlinx.io.core.Input.peekTo(destination: kotlinx.io.core.Buffer, offset: kotlin.Int = ..., min: kotlin.Int = ..., max: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.peekTo(destination: kotlinx.io.core.IoBuffer, offset: kotlin.Int = ..., min: kotlin.Int = ..., max: kotlin.Int = ...): kotlin.Int

   public inline fun <R> kotlinx.io.core.BytePacketBuilder.preview(block: (tmp: kotlinx.io.core.ByteReadPacket) -> R): R

   public fun kotlinx.io.core.Buffer.pushBack(n: kotlin.Int): kotlin.Unit

   public inline fun kotlinx.io.core.Buffer.read(block: (memory: kotlinx.io.bits.Memory, start: kotlin.Int, endExclusive: kotlin.Int) -> kotlin.Int): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailable(destination: kotlin.ByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailable(destination: kotlin.DoubleArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailable(destination: kotlin.FloatArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailable(destination: kotlin.IntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailable(destination: kotlin.LongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailable(destination: kotlin.ShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailable(destination: kotlin.UByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailable(destination: kotlin.UIntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailable(destination: kotlin.ULongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailable(destination: kotlin.UShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailable(pointer: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailable(pointer: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Int): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailable(dst: kotlinx.io.core.Buffer, length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.ByteReadPacket.readAvailable(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, limit: kotlin.Int): kotlin.Int

   public fun kotlinx.io.core.ByteReadPacket.readAvailable(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, limit: kotlin.Long): kotlin.Long

   public fun kotlinx.io.core.Input.readAvailable(dst: kotlin.ByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailable(dst: kotlin.DoubleArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailable(dst: kotlin.FloatArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailable(dst: kotlin.IntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailable(dst: kotlin.LongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailable(dst: kotlin.ShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailable(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailable(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Long

   public fun kotlinx.io.core.Input.readAvailable(destination: kotlinx.io.bits.Memory, destinationOffset: kotlin.Int, length: kotlin.Int): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailable(destination: kotlinx.io.bits.Memory, destinationOffset: kotlin.Long, length: kotlin.Long): kotlin.Long

   public fun kotlinx.io.core.Input.readAvailable(dst: kotlinx.io.core.Buffer, length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailable(dst: kotlinx.io.core.IoBuffer, size: kotlin.Int = ...): kotlin.Int

   public inline fun kotlinx.io.core.IoBuffer.readAvailable(destination: kotlin.ByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailableLittleEndian(dst: kotlin.DoubleArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailableLittleEndian(dst: kotlin.FloatArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailableLittleEndian(dst: kotlin.IntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailableLittleEndian(dst: kotlin.LongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailableLittleEndian(dst: kotlin.ShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailableLittleEndian(dst: kotlin.UIntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailableLittleEndian(dst: kotlin.ULongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Buffer.readAvailableLittleEndian(dst: kotlin.UShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailableLittleEndian(dst: kotlin.DoubleArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailableLittleEndian(dst: kotlin.FloatArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailableLittleEndian(dst: kotlin.IntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailableLittleEndian(dst: kotlin.LongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailableLittleEndian(dst: kotlin.ShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailableLittleEndian(dst: kotlin.UIntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailableLittleEndian(dst: kotlin.ULongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailableLittleEndian(dst: kotlin.UShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailableOld(dst: kotlin.ByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailableOld(dst: kotlin.DoubleArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailableOld(dst: kotlin.FloatArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailableOld(dst: kotlin.IntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailableOld(dst: kotlin.LongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readAvailableOld(dst: kotlin.ShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Buffer.readBytes(count: kotlin.Int = ...): kotlin.ByteArray

   public fun kotlinx.io.core.ByteReadPacket.readBytes(n: kotlin.Int = ...): kotlin.ByteArray

   public fun kotlinx.io.core.Input.readBytes(): kotlin.ByteArray

   public fun kotlinx.io.core.Input.readBytes(n: kotlin.Int): kotlin.ByteArray

   public fun kotlinx.io.core.Input.readBytesOf(min: kotlin.Int = ..., max: kotlin.Int = ...): kotlin.ByteArray

   public inline fun kotlinx.io.core.Buffer.readDirect(block: (kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>) -> kotlin.Int): kotlin.Int

   public fun kotlinx.io.core.Buffer.readDouble(): kotlin.Double

   public fun kotlinx.io.core.Input.readDouble(): kotlin.Double

   public fun kotlinx.io.core.Input.readDouble(byteOrder: kotlinx.io.core.ByteOrder): kotlin.Double

   public inline fun kotlinx.io.core.IoBuffer.readDouble(): kotlin.Double

   public fun kotlinx.io.core.Input.readDoubleFallback(): kotlin.Double

   public fun kotlinx.io.core.Buffer.readDoubleLittleEndian(): kotlin.Double

   public fun kotlinx.io.core.Input.readDoubleLittleEndian(): kotlin.Double

   public fun kotlinx.io.core.Buffer.readFloat(): kotlin.Float

   public fun kotlinx.io.core.Input.readFloat(): kotlin.Float

   public fun kotlinx.io.core.Input.readFloat(byteOrder: kotlinx.io.core.ByteOrder): kotlin.Float

   public inline fun kotlinx.io.core.IoBuffer.readFloat(): kotlin.Float

   public fun kotlinx.io.core.Input.readFloatFallback(): kotlin.Float

   public fun kotlinx.io.core.Buffer.readFloatLittleEndian(): kotlin.Float

   public fun kotlinx.io.core.Input.readFloatLittleEndian(): kotlin.Float

   public fun kotlinx.io.core.Buffer.readFully(dst: kotlin.Array<kotlin.Byte>, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFully(destination: kotlin.ByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFully(destination: kotlin.DoubleArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFully(destination: kotlin.FloatArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFully(destination: kotlin.IntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFully(destination: kotlin.LongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFully(destination: kotlin.ShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFully(destination: kotlin.UByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFully(destination: kotlin.UIntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFully(destination: kotlin.ULongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFully(destination: kotlin.UShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFully(pointer: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFully(pointer: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Int): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFully(dst: kotlinx.io.core.Buffer, length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.ByteReadPacket.readFully(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, size: kotlin.Int): kotlin.Int

   public fun kotlinx.io.core.ByteReadPacket.readFully(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, size: kotlin.Long): kotlin.Long

   public fun kotlinx.io.core.Input.readFully(dst: kotlin.ByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFully(dst: kotlin.DoubleArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFully(dst: kotlin.FloatArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFully(dst: kotlin.IntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFully(dst: kotlin.LongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFully(dst: kotlin.ShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.core.Input.readFully(dst: kotlin.UByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.core.Input.readFully(dst: kotlin.UIntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.core.Input.readFully(dst: kotlin.ULongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.core.Input.readFully(dst: kotlin.UShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFully(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

   public fun kotlinx.io.core.Input.readFully(dst: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Unit

   public fun kotlinx.io.core.Input.readFully(destination: kotlinx.io.bits.Memory, destinationOffset: kotlin.Int, length: kotlin.Int): kotlin.Unit

   public fun kotlinx.io.core.Input.readFully(destination: kotlinx.io.bits.Memory, destinationOffset: kotlin.Long, length: kotlin.Long): kotlin.Unit

   public fun kotlinx.io.core.Input.readFully(dst: kotlinx.io.core.Buffer, length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFully(dst: kotlinx.io.core.IoBuffer, size: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.core.IoBuffer.readFully(destination: kotlin.ByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFullyLittleEndian(dst: kotlin.DoubleArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFullyLittleEndian(dst: kotlin.FloatArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFullyLittleEndian(dst: kotlin.IntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFullyLittleEndian(dst: kotlin.LongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFullyLittleEndian(dst: kotlin.ShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFullyLittleEndian(dst: kotlin.UIntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFullyLittleEndian(dst: kotlin.ULongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readFullyLittleEndian(dst: kotlin.UShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFullyLittleEndian(dst: kotlin.DoubleArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFullyLittleEndian(dst: kotlin.FloatArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFullyLittleEndian(dst: kotlin.IntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFullyLittleEndian(dst: kotlin.LongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFullyLittleEndian(dst: kotlin.ShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFullyLittleEndian(dst: kotlin.UIntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFullyLittleEndian(dst: kotlin.ULongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFullyLittleEndian(dst: kotlin.UShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFullyOld(dst: kotlin.ByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFullyOld(dst: kotlin.DoubleArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFullyOld(dst: kotlin.FloatArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFullyOld(dst: kotlin.IntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFullyOld(dst: kotlin.LongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Input.readFullyOld(dst: kotlin.ShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.readInt(): kotlin.Int

   public fun kotlinx.io.core.Input.readInt(): kotlin.Int

   public fun kotlinx.io.core.Input.readInt(byteOrder: kotlinx.io.core.ByteOrder): kotlin.Int

   public inline fun kotlinx.io.core.IoBuffer.readInt(): kotlin.Int

   public fun kotlinx.io.core.Buffer.readIntLittleEndian(): kotlin.Int

   public fun kotlinx.io.core.Input.readIntLittleEndian(): kotlin.Int

   public fun kotlinx.io.core.Buffer.readLong(): kotlin.Long

   public fun kotlinx.io.core.Input.readLong(): kotlin.Long

   public fun kotlinx.io.core.Input.readLong(byteOrder: kotlinx.io.core.ByteOrder): kotlin.Long

   public inline fun kotlinx.io.core.IoBuffer.readLong(): kotlin.Long

   public fun kotlinx.io.core.Buffer.readLongLittleEndian(): kotlin.Long

   public fun kotlinx.io.core.Input.readLongLittleEndian(): kotlin.Long

   public fun kotlinx.io.core.Buffer.readShort(): kotlin.Short

   public fun kotlinx.io.core.Input.readShort(): kotlin.Short

   public fun kotlinx.io.core.Input.readShort(byteOrder: kotlinx.io.core.ByteOrder): kotlin.Short

   public inline fun kotlinx.io.core.IoBuffer.readShort(): kotlin.Short

   public fun kotlinx.io.core.Buffer.readShortLittleEndian(): kotlin.Short

   public fun kotlinx.io.core.Input.readShortLittleEndian(): kotlin.Short

   public fun kotlinx.io.core.Buffer.readText(charset: kotlinx.io.charsets.Charset = ..., max: kotlin.Int = ...): kotlin.String

   public fun kotlinx.io.core.Buffer.readText(decoder: kotlinx.io.charsets.CharsetDecoder, out: kotlin.text.Appendable, lastBuffer: kotlin.Boolean, max: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readText(out: kotlin.text.Appendable, charset: kotlinx.io.charsets.Charset = ..., max: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readText(out: kotlin.text.Appendable, decoder: kotlinx.io.charsets.CharsetDecoder, max: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readText(charset: kotlinx.io.charsets.Charset = ..., max: kotlin.Int = ...): kotlin.String

   public fun kotlinx.io.core.Input.readText(decoder: kotlinx.io.charsets.CharsetDecoder, max: kotlin.Int = ...): kotlin.String

   public fun kotlinx.io.core.Input.readTextExact(charset: kotlinx.io.charsets.Charset = ..., n: kotlin.Int): kotlin.String

   public fun kotlinx.io.core.Input.readTextExactBytes(bytesCount: kotlin.Int, charset: kotlinx.io.charsets.Charset = ...): kotlin.String

   public fun kotlinx.io.core.Input.readTextExactBytes(charset: kotlinx.io.charsets.Charset = ..., bytes: kotlin.Int): kotlin.String

   public fun kotlinx.io.core.Input.readTextExactCharacters(charactersCount: kotlin.Int, charset: kotlinx.io.charsets.Charset = ...): kotlin.String

   public fun kotlinx.io.core.Buffer.readUByte(): kotlin.UByte

   public inline fun kotlinx.io.core.Input.readUByte(): kotlin.UByte

   public inline fun kotlinx.io.core.IoBuffer.readUByte(): kotlin.UByte

   public fun kotlinx.io.core.Buffer.readUInt(): kotlin.UInt

   public inline fun kotlinx.io.core.Input.readUInt(): kotlin.UInt

   public inline fun kotlinx.io.core.IoBuffer.readUInt(): kotlin.UInt

   public fun kotlinx.io.core.Buffer.readULong(): kotlin.ULong

   public inline fun kotlinx.io.core.Input.readULong(): kotlin.ULong

   public inline fun kotlinx.io.core.IoBuffer.readULong(): kotlin.ULong

   public fun kotlinx.io.core.Buffer.readUShort(): kotlin.UShort

   public inline fun kotlinx.io.core.Input.readUShort(): kotlin.UShort

   public inline fun kotlinx.io.core.IoBuffer.readUShort(): kotlin.UShort

   public fun kotlinx.io.core.ByteReadPacket.readUTF8Line(estimate: kotlin.Int = ..., limit: kotlin.Int = ...): kotlin.String?

   public fun kotlinx.io.core.Input.readUTF8Line(estimate: kotlin.Int = ..., limit: kotlin.Int = ...): kotlin.String?

   public fun kotlinx.io.core.Input.readUTF8LineTo(out: kotlin.text.Appendable, limit: kotlin.Int): kotlin.Boolean

   public fun kotlinx.io.core.Input.readUTF8UntilDelimiter(delimiters: kotlin.String, limit: kotlin.Int = ...): kotlin.String

   public fun kotlinx.io.core.Input.readUTF8UntilDelimiterTo(out: kotlin.text.Appendable, delimiters: kotlin.String, limit: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readUTF8UntilDelimiterTo(out: kotlinx.io.core.BytePacketBuilderBase, delimiters: kotlin.String, limit: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readUTF8UntilDelimiterTo(out: kotlinx.io.core.Output, delimiters: kotlin.String, limit: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readUntilDelimiter(delimiter: kotlin.Byte, dst: kotlin.ByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readUntilDelimiter(delimiter: kotlin.Byte, dst: kotlinx.io.core.Output): kotlin.Long

   public fun kotlinx.io.core.Input.readUntilDelimiters(delimiter1: kotlin.Byte, delimiter2: kotlin.Byte, dst: kotlin.ByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Int

   public fun kotlinx.io.core.Input.readUntilDelimiters(delimiter1: kotlin.Byte, delimiter2: kotlin.Byte, dst: kotlinx.io.core.Output): kotlin.Long

   public fun kotlinx.io.core.IoBuffer.release(pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.IoBuffer>): kotlin.Unit

   public fun kotlinx.io.core.internal.ChunkBuffer.remainingAll(): kotlin.Long

   public fun kotlinx.io.core.BytePacketBuilder.reset(): kotlin.Unit

   public inline fun kotlinx.io.core.Input.takeWhile(block: (kotlinx.io.core.Buffer) -> kotlin.Boolean): kotlin.Unit

   public inline fun kotlinx.io.core.Input.takeWhileSize(initialSize: kotlin.Int = ..., block: (kotlinx.io.core.Buffer) -> kotlin.Int): kotlin.Unit

   public inline fun kotlin.String.toByteArray(charset: kotlinx.io.charsets.Charset = ...): kotlin.ByteArray

   public fun kotlinx.io.core.Buffer.tryPeek(): kotlin.Int

   public inline fun <C : kotlinx.io.core.Closeable, R> C.use(block: (C) -> R): R

   public inline fun <I : kotlinx.io.core.Input, R> I.use(block: (I) -> R): R

   public inline fun <O : kotlinx.io.core.Output, R> O.use(block: (O) -> R): R

   public inline fun kotlinx.io.core.Buffer.write(block: (memory: kotlinx.io.bits.Memory, start: kotlin.Int, endExclusive: kotlin.Int) -> kotlin.Int): kotlin.Int

   public inline fun kotlinx.io.core.Buffer.writeDirect(block: (kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>) -> kotlin.Int): kotlin.Int

   public fun kotlinx.io.core.Buffer.writeDouble(value: kotlin.Double): kotlin.Unit

   public inline fun kotlinx.io.core.IoBuffer.writeDouble(value: kotlin.Double): kotlin.Unit

   public fun kotlinx.io.core.Output.writeDouble(value: kotlin.Double): kotlin.Unit

   public fun kotlinx.io.core.Output.writeDouble(value: kotlin.Double, byteOrder: kotlinx.io.core.ByteOrder): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeDoubleLittleEndian(value: kotlin.Double): kotlin.Unit

   public fun kotlinx.io.core.Output.writeDoubleLittleEndian(value: kotlin.Double): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFloat(value: kotlin.Float): kotlin.Unit

   public inline fun kotlinx.io.core.IoBuffer.writeFloat(value: kotlin.Float): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFloat(value: kotlin.Float): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFloat(value: kotlin.Float, byteOrder: kotlinx.io.core.ByteOrder): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFloatLittleEndian(value: kotlin.Float): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFloatLittleEndian(value: kotlin.Float): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFully(source: kotlin.ByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFully(source: kotlin.DoubleArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFully(source: kotlin.FloatArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFully(source: kotlin.IntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFully(source: kotlin.LongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFully(source: kotlin.ShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFully(source: kotlin.UByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFully(source: kotlin.UIntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFully(source: kotlin.ULongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFully(source: kotlin.UShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFully(pointer: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFully(pointer: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Int): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFully(src: kotlinx.io.core.Buffer): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFully(src: kotlinx.io.core.Buffer, length: kotlin.Int): kotlin.Unit

   public fun kotlinx.io.core.BytePacketBuilder.writeFully(src: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, size: kotlin.Int): kotlin.Unit

   public inline fun kotlinx.io.core.IoBuffer.writeFully(source: kotlin.ByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFully(src: kotlin.ByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFully(src: kotlin.DoubleArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFully(src: kotlin.FloatArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFully(src: kotlin.IntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFully(src: kotlin.LongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFully(src: kotlin.ShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.core.Output.writeFully(array: kotlin.UByteArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.core.Output.writeFully(array: kotlin.UIntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.core.Output.writeFully(array: kotlin.ULongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public inline fun kotlinx.io.core.Output.writeFully(array: kotlin.UShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFully(src: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFully(src: kotlinx.cinterop.CPointer<kotlinx.cinterop.ByteVar /* = kotlinx.cinterop.ByteVarOf<kotlin.Byte> */>, offset: kotlin.Long, length: kotlin.Long): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFully(src: kotlinx.io.bits.Memory, offset: kotlin.Int, length: kotlin.Int): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFully(src: kotlinx.io.bits.Memory, offset: kotlin.Long, length: kotlin.Long): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFully(src: kotlinx.io.core.Buffer, length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFully(src: kotlinx.io.core.IoBuffer, length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFullyLittleEndian(source: kotlin.DoubleArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFullyLittleEndian(source: kotlin.FloatArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFullyLittleEndian(source: kotlin.IntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFullyLittleEndian(source: kotlin.LongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFullyLittleEndian(source: kotlin.ShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFullyLittleEndian(source: kotlin.UIntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFullyLittleEndian(source: kotlin.ULongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeFullyLittleEndian(source: kotlin.UShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFullyLittleEndian(source: kotlin.DoubleArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFullyLittleEndian(source: kotlin.FloatArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFullyLittleEndian(source: kotlin.IntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFullyLittleEndian(source: kotlin.LongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFullyLittleEndian(source: kotlin.ShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFullyLittleEndian(source: kotlin.UIntArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFullyLittleEndian(source: kotlin.ULongArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Output.writeFullyLittleEndian(source: kotlin.UShortArray, offset: kotlin.Int = ..., length: kotlin.Int = ...): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeInt(value: kotlin.Int): kotlin.Unit

   public inline fun kotlinx.io.core.IoBuffer.writeInt(value: kotlin.Int): kotlin.Unit

   public fun kotlinx.io.core.Output.writeInt(value: kotlin.Int): kotlin.Unit

   public fun kotlinx.io.core.Output.writeInt(value: kotlin.Int, byteOrder: kotlinx.io.core.ByteOrder): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeIntLittleEndian(value: kotlin.Int): kotlin.Unit

   public fun kotlinx.io.core.Output.writeIntLittleEndian(value: kotlin.Int): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeLong(value: kotlin.Long): kotlin.Unit

   public inline fun kotlinx.io.core.IoBuffer.writeLong(value: kotlin.Long): kotlin.Unit

   public fun kotlinx.io.core.Output.writeLong(value: kotlin.Long): kotlin.Unit

   public fun kotlinx.io.core.Output.writeLong(value: kotlin.Long, byteOrder: kotlinx.io.core.ByteOrder): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeLongLittleEndian(value: kotlin.Long): kotlin.Unit

   public fun kotlinx.io.core.Output.writeLongLittleEndian(value: kotlin.Long): kotlin.Unit

   public fun kotlinx.io.core.Output.writePacket(packet: kotlinx.io.core.ByteReadPacket): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeShort(value: kotlin.Short): kotlin.Unit

   public inline fun kotlinx.io.core.IoBuffer.writeShort(value: kotlin.Short): kotlin.Unit

   public fun kotlinx.io.core.Output.writeShort(value: kotlin.Short): kotlin.Unit

   public fun kotlinx.io.core.Output.writeShort(value: kotlin.Short, byteOrder: kotlinx.io.core.ByteOrder): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeShortLittleEndian(value: kotlin.Short): kotlin.Unit

   public fun kotlinx.io.core.Output.writeShortLittleEndian(value: kotlin.Short): kotlin.Unit

   public fun kotlinx.io.core.Output.writeText(text: kotlin.CharArray, fromIndex: kotlin.Int = ..., toIndex: kotlin.Int = ..., charset: kotlinx.io.charsets.Charset = ...): kotlin.Unit

   public fun kotlinx.io.core.Output.writeText(text: kotlin.CharSequence, fromIndex: kotlin.Int = ..., toIndex: kotlin.Int = ..., charset: kotlinx.io.charsets.Charset = ...): kotlin.Unit

   public fun kotlinx.io.core.Output.writeText(text: kotlin.CharSequence, fromIndex: kotlin.Int = ..., toIndex: kotlin.Int = ..., encoder: kotlinx.io.charsets.CharsetEncoder): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeUByte(value: kotlin.UByte): kotlin.Unit

   public fun kotlinx.io.core.IoBuffer.writeUByte(value: kotlin.UByte): kotlin.Unit

   public inline fun kotlinx.io.core.Output.writeUByte(v: kotlin.UByte): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeUInt(value: kotlin.UInt): kotlin.Unit

   public inline fun kotlinx.io.core.IoBuffer.writeUInt(value: kotlin.UInt): kotlin.Unit

   public inline fun kotlinx.io.core.Output.writeUInt(v: kotlin.UInt): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeULong(value: kotlin.ULong): kotlin.Unit

   public inline fun kotlinx.io.core.IoBuffer.writeULong(value: kotlin.ULong): kotlin.Unit

   public inline fun kotlinx.io.core.Output.writeULong(v: kotlin.ULong): kotlin.Unit

   public fun kotlinx.io.core.Buffer.writeUShort(value: kotlin.UShort): kotlin.Unit

   public inline fun kotlinx.io.core.IoBuffer.writeUShort(value: kotlin.UShort): kotlin.Unit

   public inline fun kotlinx.io.core.Output.writeUShort(v: kotlin.UShort): kotlin.Unit

   public inline fun kotlinx.io.core.Output.writeWhile(block: (kotlinx.io.core.Buffer) -> kotlin.Boolean): kotlin.Unit

   public inline fun kotlinx.io.core.Output.writeWhileSize(initialSize: kotlin.Int = ..., block: (kotlinx.io.core.Buffer) -> kotlin.Int): kotlin.Unit

}

package kotlinx.io.core.internal
{
   public open class ChunkBuffer : kotlinx.io.core.Buffer
   {
       public final override var attachment: kotlin.Any? { get; set; }
       public final override val capacity: kotlin.Int { get; }
       public final override val endGap: kotlin.Int { get; }
       public final override var limit: kotlin.Int { get; }
       public final override val memory: kotlinx.io.bits.Memory { get; }
       public final var next: kotlinx.io.core.internal.ChunkBuffer? { get; set; }
       public final var origin: kotlinx.io.core.internal.ChunkBuffer? { get; }
       public final override var readPosition: kotlin.Int { get; }
       public final override val readRemaining: kotlin.Int { get; }
       public final val referenceCount: kotlin.Int { get; }
       public final override var startGap: kotlin.Int { get; }
       public final override var writePosition: kotlin.Int { get; }
       public final override val writeRemaining: kotlin.Int { get; }
       public final fun cleanNext(): kotlinx.io.core.internal.ChunkBuffer?

       public final override fun commitWritten(count: kotlin.Int): kotlin.Unit

       public final override fun discard(count: kotlin.Int): kotlin.Int

       public final override fun discard(count: kotlin.Long): kotlin.Long

       public final override fun discardExact(count: kotlin.Int = ...): kotlin.Unit

       public open override fun duplicate(): kotlinx.io.core.internal.ChunkBuffer

       protected open override fun duplicateTo(copy: kotlinx.io.core.Buffer): kotlin.Unit

       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public open override fun hashCode(): kotlin.Int

       public final override fun readByte(): kotlin.Byte

       public open fun release(pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer>): kotlin.Unit

       public final override fun reserveEndGap(endGap: kotlin.Int): kotlin.Unit

       public final override fun reserveStartGap(startGap: kotlin.Int): kotlin.Unit

       public final override fun reset(): kotlin.Unit

       public final override fun resetForRead(): kotlin.Unit

       public final override fun resetForWrite(): kotlin.Unit

       public final override fun resetForWrite(limit: kotlin.Int): kotlin.Unit

       public final override fun rewind(count: kotlin.Int = ...): kotlin.Unit

       public open override fun toString(): kotlin.String

       public final override fun tryPeekByte(): kotlin.Int

       public final override fun tryReadByte(): kotlin.Int

       public final override fun writeByte(value: kotlin.Byte): kotlin.Unit

       public companion object of ChunkBuffer
       {
           public final val Empty: kotlinx.io.core.internal.ChunkBuffer { get; }
           public final val EmptyPool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer> { get; }
           public final val Pool: kotlinx.io.pool.ObjectPool<kotlinx.io.core.internal.ChunkBuffer> { get; }
           public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

           public open override fun hashCode(): kotlin.Int

           public open override fun toString(): kotlin.String

       }

   }

   public final annotation class DangerousInternalIoApi : kotlin.Annotation
   {
       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public open override fun hashCode(): kotlin.Int

       public open override fun toString(): kotlin.String

       public constructor DangerousInternalIoApi()

   }

   public final class MalformedUTF8InputException : kotlin.Exception
   {
       public open override val cause: kotlin.Throwable? { get; }
       public open override val message: kotlin.String? { get; }
       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public final override fun getStackTrace(): kotlin.Array<kotlin.String>

       public open override fun hashCode(): kotlin.Int

       public final override fun printStackTrace(): kotlin.Unit

       public open override fun toString(): kotlin.String

       public constructor MalformedUTF8InputException(message: kotlin.String)

   }

   public suspend fun decodeUTF8LineLoopSuspend(out: kotlin.text.Appendable, limit: kotlin.Int, nextChunk: suspend (kotlin.Int) -> kotlinx.io.core.AbstractInput?): kotlin.Boolean

   public fun kotlinx.io.core.ByteReadPacket.`$unsafeAppend$`(builder: kotlinx.io.core.BytePacketBuilder): kotlin.Unit

   public fun kotlinx.io.core.Output.afterHeadWrite(current: kotlinx.io.core.IoBuffer): kotlin.Unit

   public fun kotlinx.io.core.Output.afterHeadWrite(current: kotlinx.io.core.internal.ChunkBuffer): kotlin.Unit

   public fun kotlinx.io.core.Input.completeReadHead(current: kotlinx.io.core.IoBuffer): kotlin.Unit

   public fun kotlinx.io.core.Input.completeReadHead(current: kotlinx.io.core.internal.ChunkBuffer): kotlin.Unit

   public inline fun kotlinx.io.core.Buffer.decodeUTF8(consumer: (kotlin.Char) -> kotlin.Boolean): kotlin.Int

   public inline fun kotlinx.io.core.IoBuffer.decodeUTF8(consumer: (kotlin.Char) -> kotlin.Boolean): kotlin.Int

   public fun kotlinx.io.core.Input.prepareReadFirstHead(minSize: kotlin.Int): kotlinx.io.core.internal.ChunkBuffer?

   public fun kotlinx.io.core.Input.prepareReadFirstHeadOld(minSize: kotlin.Int): kotlinx.io.core.IoBuffer?

   public fun kotlinx.io.core.Input.prepareReadNextHead(current: kotlinx.io.core.internal.ChunkBuffer): kotlinx.io.core.internal.ChunkBuffer?

   public fun kotlinx.io.core.Input.prepareReadNextHeadOld(current: kotlinx.io.core.IoBuffer): kotlinx.io.core.IoBuffer?

   public fun kotlinx.io.core.Output.prepareWriteHead(capacity: kotlin.Int, current: kotlinx.io.core.IoBuffer?): kotlinx.io.core.IoBuffer

   public fun kotlinx.io.core.Output.prepareWriteHead(capacity: kotlin.Int, current: kotlinx.io.core.internal.ChunkBuffer?): kotlinx.io.core.internal.ChunkBuffer

}

package kotlinx.io.pool
{
   public abstract class DefaultPool<T : kotlin.Any> : kotlinx.io.pool.ObjectPool<T>
   {
       public final override val capacity: kotlin.Int { get; }
       public final override fun borrow(): T

       protected open fun clearInstance(instance: T): T

       public open override fun close(): kotlin.Unit

       public final override fun dispose(): kotlin.Unit

       protected open fun disposeInstance(instance: T): kotlin.Unit

       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public open override fun hashCode(): kotlin.Int

       protected abstract fun produceInstance(): T

       public final override fun recycle(instance: T): kotlin.Unit

       public open override fun toString(): kotlin.String

       protected open fun validateInstance(instance: T): kotlin.Unit

       public constructor DefaultPool<T : kotlin.Any>(capacity: kotlin.Int)

   }

   public abstract class NoPoolImpl<T : kotlin.Any> : kotlinx.io.pool.ObjectPool<T>
   {
       public open override val capacity: kotlin.Int { get; }
       public abstract override fun borrow(): T

       public open override fun close(): kotlin.Unit

       public open override fun dispose(): kotlin.Unit

       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public open override fun hashCode(): kotlin.Int

       public open override fun recycle(instance: T): kotlin.Unit

       public open override fun toString(): kotlin.String

       public constructor NoPoolImpl<T : kotlin.Any>()

   }

   public interface ObjectPool<T : kotlin.Any> : kotlinx.io.core.Closeable
   {
       public abstract val capacity: kotlin.Int { get; }
       public abstract fun borrow(): T

       public open override fun close(): kotlin.Unit

       public abstract fun dispose(): kotlin.Unit

       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public open override fun hashCode(): kotlin.Int

       public abstract fun recycle(instance: T): kotlin.Unit

       public open override fun toString(): kotlin.String

   }

   public abstract class SingleInstancePool<T : kotlin.Any> : kotlinx.io.pool.ObjectPool<T>
   {
       public final override val capacity: kotlin.Int { get; }
       public final override fun borrow(): T

       public open override fun close(): kotlin.Unit

       public final override fun dispose(): kotlin.Unit

       protected abstract fun disposeInstance(instance: T): kotlin.Unit

       public open external override operator fun equals(other: kotlin.Any?): kotlin.Boolean

       public open override fun hashCode(): kotlin.Int

       protected abstract fun produceInstance(): T

       public final override fun recycle(instance: T): kotlin.Unit

       public open override fun toString(): kotlin.String

       public constructor SingleInstancePool<T : kotlin.Any>()

   }

   public inline fun <T : kotlin.Any, R> kotlinx.io.pool.ObjectPool<T>.useBorrowed(block: (T) -> R): R

   public inline fun <T : kotlin.Any, R> kotlinx.io.pool.ObjectPool<T>.useInstance(block: (T) -> R): R

}

